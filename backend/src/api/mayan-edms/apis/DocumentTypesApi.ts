/* tslint:disable */
/* eslint-disable */
/**
 * Mayan EDMS API
 * Free Open Source Electronic Document Management System
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CabinetsDocumentsList200Response,
  DocumentType,
  DocumentTypeDriverConfiguration,
  DocumentTypeMetadataType,
  DocumentTypeOCRSettings,
  DocumentTypeParsingSettings,
  DocumentTypeQuickLabel,
  DocumentTypesFileMetadataDriversList200Response,
  DocumentTypesList200Response,
  DocumentTypesMetadataTypesList200Response,
  DocumentTypesQuickLabelsList200Response,
} from '../models/index';
import {
    CabinetsDocumentsList200ResponseFromJSON,
    CabinetsDocumentsList200ResponseToJSON,
    DocumentTypeFromJSON,
    DocumentTypeToJSON,
    DocumentTypeDriverConfigurationFromJSON,
    DocumentTypeDriverConfigurationToJSON,
    DocumentTypeMetadataTypeFromJSON,
    DocumentTypeMetadataTypeToJSON,
    DocumentTypeOCRSettingsFromJSON,
    DocumentTypeOCRSettingsToJSON,
    DocumentTypeParsingSettingsFromJSON,
    DocumentTypeParsingSettingsToJSON,
    DocumentTypeQuickLabelFromJSON,
    DocumentTypeQuickLabelToJSON,
    DocumentTypesFileMetadataDriversList200ResponseFromJSON,
    DocumentTypesFileMetadataDriversList200ResponseToJSON,
    DocumentTypesList200ResponseFromJSON,
    DocumentTypesList200ResponseToJSON,
    DocumentTypesMetadataTypesList200ResponseFromJSON,
    DocumentTypesMetadataTypesList200ResponseToJSON,
    DocumentTypesQuickLabelsList200ResponseFromJSON,
    DocumentTypesQuickLabelsList200ResponseToJSON,
} from '../models/index';

export interface DocumentTypesCreateRequest {
    data: Omit<DocumentType, 'documents_url'|'id'|'quick_label_list_url'|'url'>;
}

export interface DocumentTypesDeleteRequest {
    documentTypeId: string;
}

export interface DocumentTypesDocumentsListRequest {
    documentTypeId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentTypesFileMetadataDriversListRequest {
    documentTypeId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentTypesFileMetadataDriversPartialUpdateRequest {
    documentTypeId: string;
    driverId: string;
    data: Omit<DocumentTypeDriverConfiguration, 'url'>;
}

export interface DocumentTypesFileMetadataDriversReadRequest {
    documentTypeId: string;
    driverId: string;
}

export interface DocumentTypesFileMetadataDriversUpdateRequest {
    documentTypeId: string;
    driverId: string;
    data: Omit<DocumentTypeDriverConfiguration, 'url'>;
}

export interface DocumentTypesListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentTypesMetadataTypesCreateRequest {
    documentTypeId: string;
    data: Omit<DocumentTypeMetadataType, 'id'|'url'>;
}

export interface DocumentTypesMetadataTypesDeleteRequest {
    documentTypeId: string;
    metadataTypeId: string;
}

export interface DocumentTypesMetadataTypesListRequest {
    documentTypeId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentTypesMetadataTypesPartialUpdateRequest {
    documentTypeId: string;
    metadataTypeId: string;
    data: Omit<DocumentTypeMetadataType, 'id'|'url'>;
}

export interface DocumentTypesMetadataTypesReadRequest {
    documentTypeId: string;
    metadataTypeId: string;
}

export interface DocumentTypesMetadataTypesUpdateRequest {
    documentTypeId: string;
    metadataTypeId: string;
    data: Omit<DocumentTypeMetadataType, 'id'|'url'>;
}

export interface DocumentTypesOcrSettingsPartialUpdateRequest {
    documentTypeId: string;
    data: DocumentTypeOCRSettings;
}

export interface DocumentTypesOcrSettingsReadRequest {
    documentTypeId: string;
}

export interface DocumentTypesOcrSettingsUpdateRequest {
    documentTypeId: string;
    data: DocumentTypeOCRSettings;
}

export interface DocumentTypesParsingSettingsPartialUpdateRequest {
    documentTypeId: string;
    data: DocumentTypeParsingSettings;
}

export interface DocumentTypesParsingSettingsReadRequest {
    documentTypeId: string;
}

export interface DocumentTypesParsingSettingsUpdateRequest {
    documentTypeId: string;
    data: DocumentTypeParsingSettings;
}

export interface DocumentTypesPartialUpdateRequest {
    documentTypeId: string;
    data: Omit<DocumentType, 'documents_url'|'id'|'quick_label_list_url'|'url'>;
}

export interface DocumentTypesQuickLabelsCreateRequest {
    documentTypeId: string;
    data: Omit<DocumentTypeQuickLabel, 'document_type_url'|'id'|'url'>;
}

export interface DocumentTypesQuickLabelsDeleteRequest {
    documentTypeId: string;
    documentTypeQuickLabelId: string;
}

export interface DocumentTypesQuickLabelsListRequest {
    documentTypeId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentTypesQuickLabelsPartialUpdateRequest {
    documentTypeId: string;
    documentTypeQuickLabelId: string;
    data: Omit<DocumentTypeQuickLabel, 'document_type_url'|'id'|'url'>;
}

export interface DocumentTypesQuickLabelsReadRequest {
    documentTypeId: string;
    documentTypeQuickLabelId: string;
}

export interface DocumentTypesQuickLabelsUpdateRequest {
    documentTypeId: string;
    documentTypeQuickLabelId: string;
    data: Omit<DocumentTypeQuickLabel, 'document_type_url'|'id'|'url'>;
}

export interface DocumentTypesReadRequest {
    documentTypeId: string;
}

export interface DocumentTypesUpdateRequest {
    documentTypeId: string;
    data: Omit<DocumentType, 'documents_url'|'id'|'quick_label_list_url'|'url'>;
}

/**
 * 
 */
export class DocumentTypesApi extends runtime.BaseAPI {

    /**
     * Create a new document type.
     */
    async documentTypesCreateRaw(requestParameters: DocumentTypesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentType>> {
        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeFromJSON(jsonValue));
    }

    /**
     * Create a new document type.
     */
    async documentTypesCreate(requestParameters: DocumentTypesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentType> {
        const response = await this.documentTypesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the selected document type.
     */
    async documentTypesDeleteRaw(requestParameters: DocumentTypesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the selected document type.
     */
    async documentTypesDelete(requestParameters: DocumentTypesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentTypesDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a list of all the documents of the selected document types.
     */
    async documentTypesDocumentsListRaw(requestParameters: DocumentTypesDocumentsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CabinetsDocumentsList200Response>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesDocumentsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/documents/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CabinetsDocumentsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the documents of the selected document types.
     */
    async documentTypesDocumentsList(requestParameters: DocumentTypesDocumentsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CabinetsDocumentsList200Response> {
        const response = await this.documentTypesDocumentsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the list of document type file metadata settings.
     */
    async documentTypesFileMetadataDriversListRaw(requestParameters: DocumentTypesFileMetadataDriversListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypesFileMetadataDriversList200Response>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesFileMetadataDriversList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/file_metadata/drivers/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypesFileMetadataDriversList200ResponseFromJSON(jsonValue));
    }

    /**
     * Return the list of document type file metadata settings.
     */
    async documentTypesFileMetadataDriversList(requestParameters: DocumentTypesFileMetadataDriversListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypesFileMetadataDriversList200Response> {
        const response = await this.documentTypesFileMetadataDriversListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set the selected document type file metadata settings.
     */
    async documentTypesFileMetadataDriversPartialUpdateRaw(requestParameters: DocumentTypesFileMetadataDriversPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeDriverConfiguration>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesFileMetadataDriversPartialUpdate().'
            );
        }

        if (requestParameters['driverId'] == null) {
            throw new runtime.RequiredError(
                'driverId',
                'Required parameter "driverId" was null or undefined when calling documentTypesFileMetadataDriversPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesFileMetadataDriversPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/file_metadata/drivers/{driver_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));
        urlPath = urlPath.replace(`{${"driver_id"}}`, encodeURIComponent(String(requestParameters['driverId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeDriverConfigurationToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeDriverConfigurationFromJSON(jsonValue));
    }

    /**
     * Set the selected document type file metadata settings.
     */
    async documentTypesFileMetadataDriversPartialUpdate(requestParameters: DocumentTypesFileMetadataDriversPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeDriverConfiguration> {
        const response = await this.documentTypesFileMetadataDriversPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the selected document type file metadata settings.
     */
    async documentTypesFileMetadataDriversReadRaw(requestParameters: DocumentTypesFileMetadataDriversReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeDriverConfiguration>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesFileMetadataDriversRead().'
            );
        }

        if (requestParameters['driverId'] == null) {
            throw new runtime.RequiredError(
                'driverId',
                'Required parameter "driverId" was null or undefined when calling documentTypesFileMetadataDriversRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/file_metadata/drivers/{driver_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));
        urlPath = urlPath.replace(`{${"driver_id"}}`, encodeURIComponent(String(requestParameters['driverId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeDriverConfigurationFromJSON(jsonValue));
    }

    /**
     * Return the selected document type file metadata settings.
     */
    async documentTypesFileMetadataDriversRead(requestParameters: DocumentTypesFileMetadataDriversReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeDriverConfiguration> {
        const response = await this.documentTypesFileMetadataDriversReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set the selected document type file metadata settings.
     */
    async documentTypesFileMetadataDriversUpdateRaw(requestParameters: DocumentTypesFileMetadataDriversUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeDriverConfiguration>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesFileMetadataDriversUpdate().'
            );
        }

        if (requestParameters['driverId'] == null) {
            throw new runtime.RequiredError(
                'driverId',
                'Required parameter "driverId" was null or undefined when calling documentTypesFileMetadataDriversUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesFileMetadataDriversUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/file_metadata/drivers/{driver_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));
        urlPath = urlPath.replace(`{${"driver_id"}}`, encodeURIComponent(String(requestParameters['driverId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeDriverConfigurationToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeDriverConfigurationFromJSON(jsonValue));
    }

    /**
     * Set the selected document type file metadata settings.
     */
    async documentTypesFileMetadataDriversUpdate(requestParameters: DocumentTypesFileMetadataDriversUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeDriverConfiguration> {
        const response = await this.documentTypesFileMetadataDriversUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all the document types.
     */
    async documentTypesListRaw(requestParameters: DocumentTypesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypesList200Response>> {
        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypesList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the document types.
     */
    async documentTypesList(requestParameters: DocumentTypesListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypesList200Response> {
        const response = await this.documentTypesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a metadata type to the selected document type.
     */
    async documentTypesMetadataTypesCreateRaw(requestParameters: DocumentTypesMetadataTypesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeMetadataType>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesMetadataTypesCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesMetadataTypesCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/metadata_types/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeMetadataTypeToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeMetadataTypeFromJSON(jsonValue));
    }

    /**
     * Add a metadata type to the selected document type.
     */
    async documentTypesMetadataTypesCreate(requestParameters: DocumentTypesMetadataTypesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeMetadataType> {
        const response = await this.documentTypesMetadataTypesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a metadata type from a document type.
     */
    async documentTypesMetadataTypesDeleteRaw(requestParameters: DocumentTypesMetadataTypesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesMetadataTypesDelete().'
            );
        }

        if (requestParameters['metadataTypeId'] == null) {
            throw new runtime.RequiredError(
                'metadataTypeId',
                'Required parameter "metadataTypeId" was null or undefined when calling documentTypesMetadataTypesDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/metadata_types/{metadata_type_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));
        urlPath = urlPath.replace(`{${"metadata_type_id"}}`, encodeURIComponent(String(requestParameters['metadataTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a metadata type from a document type.
     */
    async documentTypesMetadataTypesDelete(requestParameters: DocumentTypesMetadataTypesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentTypesMetadataTypesDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a list of selected document type\'s metadata types.
     */
    async documentTypesMetadataTypesListRaw(requestParameters: DocumentTypesMetadataTypesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypesMetadataTypesList200Response>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesMetadataTypesList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/metadata_types/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypesMetadataTypesList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of selected document type\'s metadata types.
     */
    async documentTypesMetadataTypesList(requestParameters: DocumentTypesMetadataTypesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypesMetadataTypesList200Response> {
        const response = await this.documentTypesMetadataTypesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the selected document type metadata type.
     */
    async documentTypesMetadataTypesPartialUpdateRaw(requestParameters: DocumentTypesMetadataTypesPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeMetadataType>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesMetadataTypesPartialUpdate().'
            );
        }

        if (requestParameters['metadataTypeId'] == null) {
            throw new runtime.RequiredError(
                'metadataTypeId',
                'Required parameter "metadataTypeId" was null or undefined when calling documentTypesMetadataTypesPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesMetadataTypesPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/metadata_types/{metadata_type_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));
        urlPath = urlPath.replace(`{${"metadata_type_id"}}`, encodeURIComponent(String(requestParameters['metadataTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeMetadataTypeToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeMetadataTypeFromJSON(jsonValue));
    }

    /**
     * Edit the selected document type metadata type.
     */
    async documentTypesMetadataTypesPartialUpdate(requestParameters: DocumentTypesMetadataTypesPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeMetadataType> {
        const response = await this.documentTypesMetadataTypesPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the details of a document type metadata type.
     */
    async documentTypesMetadataTypesReadRaw(requestParameters: DocumentTypesMetadataTypesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeMetadataType>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesMetadataTypesRead().'
            );
        }

        if (requestParameters['metadataTypeId'] == null) {
            throw new runtime.RequiredError(
                'metadataTypeId',
                'Required parameter "metadataTypeId" was null or undefined when calling documentTypesMetadataTypesRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/metadata_types/{metadata_type_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));
        urlPath = urlPath.replace(`{${"metadata_type_id"}}`, encodeURIComponent(String(requestParameters['metadataTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeMetadataTypeFromJSON(jsonValue));
    }

    /**
     * Retrieve the details of a document type metadata type.
     */
    async documentTypesMetadataTypesRead(requestParameters: DocumentTypesMetadataTypesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeMetadataType> {
        const response = await this.documentTypesMetadataTypesReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the selected document type metadata type.
     */
    async documentTypesMetadataTypesUpdateRaw(requestParameters: DocumentTypesMetadataTypesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeMetadataType>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesMetadataTypesUpdate().'
            );
        }

        if (requestParameters['metadataTypeId'] == null) {
            throw new runtime.RequiredError(
                'metadataTypeId',
                'Required parameter "metadataTypeId" was null or undefined when calling documentTypesMetadataTypesUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesMetadataTypesUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/metadata_types/{metadata_type_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));
        urlPath = urlPath.replace(`{${"metadata_type_id"}}`, encodeURIComponent(String(requestParameters['metadataTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeMetadataTypeToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeMetadataTypeFromJSON(jsonValue));
    }

    /**
     * Edit the selected document type metadata type.
     */
    async documentTypesMetadataTypesUpdate(requestParameters: DocumentTypesMetadataTypesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeMetadataType> {
        const response = await this.documentTypesMetadataTypesUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set the document type OCR settings.
     */
    async documentTypesOcrSettingsPartialUpdateRaw(requestParameters: DocumentTypesOcrSettingsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeOCRSettings>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesOcrSettingsPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesOcrSettingsPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/ocr/settings/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeOCRSettingsToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeOCRSettingsFromJSON(jsonValue));
    }

    /**
     * Set the document type OCR settings.
     */
    async documentTypesOcrSettingsPartialUpdate(requestParameters: DocumentTypesOcrSettingsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeOCRSettings> {
        const response = await this.documentTypesOcrSettingsPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the document type OCR settings.
     */
    async documentTypesOcrSettingsReadRaw(requestParameters: DocumentTypesOcrSettingsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeOCRSettings>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesOcrSettingsRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/ocr/settings/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeOCRSettingsFromJSON(jsonValue));
    }

    /**
     * Return the document type OCR settings.
     */
    async documentTypesOcrSettingsRead(requestParameters: DocumentTypesOcrSettingsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeOCRSettings> {
        const response = await this.documentTypesOcrSettingsReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set the document type OCR settings.
     */
    async documentTypesOcrSettingsUpdateRaw(requestParameters: DocumentTypesOcrSettingsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeOCRSettings>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesOcrSettingsUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesOcrSettingsUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/ocr/settings/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeOCRSettingsToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeOCRSettingsFromJSON(jsonValue));
    }

    /**
     * Set the document type OCR settings.
     */
    async documentTypesOcrSettingsUpdate(requestParameters: DocumentTypesOcrSettingsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeOCRSettings> {
        const response = await this.documentTypesOcrSettingsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set the document type parsing settings.
     */
    async documentTypesParsingSettingsPartialUpdateRaw(requestParameters: DocumentTypesParsingSettingsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeParsingSettings>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesParsingSettingsPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesParsingSettingsPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/parsing/settings/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeParsingSettingsToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeParsingSettingsFromJSON(jsonValue));
    }

    /**
     * Set the document type parsing settings.
     */
    async documentTypesParsingSettingsPartialUpdate(requestParameters: DocumentTypesParsingSettingsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeParsingSettings> {
        const response = await this.documentTypesParsingSettingsPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the document type parsing settings.
     */
    async documentTypesParsingSettingsReadRaw(requestParameters: DocumentTypesParsingSettingsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeParsingSettings>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesParsingSettingsRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/parsing/settings/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeParsingSettingsFromJSON(jsonValue));
    }

    /**
     * Return the document type parsing settings.
     */
    async documentTypesParsingSettingsRead(requestParameters: DocumentTypesParsingSettingsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeParsingSettings> {
        const response = await this.documentTypesParsingSettingsReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set the document type parsing settings.
     */
    async documentTypesParsingSettingsUpdateRaw(requestParameters: DocumentTypesParsingSettingsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeParsingSettings>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesParsingSettingsUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesParsingSettingsUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/parsing/settings/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeParsingSettingsToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeParsingSettingsFromJSON(jsonValue));
    }

    /**
     * Set the document type parsing settings.
     */
    async documentTypesParsingSettingsUpdate(requestParameters: DocumentTypesParsingSettingsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeParsingSettings> {
        const response = await this.documentTypesParsingSettingsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the properties of the selected document type.
     */
    async documentTypesPartialUpdateRaw(requestParameters: DocumentTypesPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentType>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeFromJSON(jsonValue));
    }

    /**
     * Edit the properties of the selected document type.
     */
    async documentTypesPartialUpdate(requestParameters: DocumentTypesPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentType> {
        const response = await this.documentTypesPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new document type quick label.
     */
    async documentTypesQuickLabelsCreateRaw(requestParameters: DocumentTypesQuickLabelsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeQuickLabel>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesQuickLabelsCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesQuickLabelsCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/quick_labels/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeQuickLabelToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeQuickLabelFromJSON(jsonValue));
    }

    /**
     * Create a new document type quick label.
     */
    async documentTypesQuickLabelsCreate(requestParameters: DocumentTypesQuickLabelsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeQuickLabel> {
        const response = await this.documentTypesQuickLabelsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the selected quick label.
     */
    async documentTypesQuickLabelsDeleteRaw(requestParameters: DocumentTypesQuickLabelsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesQuickLabelsDelete().'
            );
        }

        if (requestParameters['documentTypeQuickLabelId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeQuickLabelId',
                'Required parameter "documentTypeQuickLabelId" was null or undefined when calling documentTypesQuickLabelsDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/quick_labels/{document_type_quick_label_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));
        urlPath = urlPath.replace(`{${"document_type_quick_label_id"}}`, encodeURIComponent(String(requestParameters['documentTypeQuickLabelId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the selected quick label.
     */
    async documentTypesQuickLabelsDelete(requestParameters: DocumentTypesQuickLabelsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentTypesQuickLabelsDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a list of all the document type quick labels.
     */
    async documentTypesQuickLabelsListRaw(requestParameters: DocumentTypesQuickLabelsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypesQuickLabelsList200Response>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesQuickLabelsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/quick_labels/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypesQuickLabelsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the document type quick labels.
     */
    async documentTypesQuickLabelsList(requestParameters: DocumentTypesQuickLabelsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypesQuickLabelsList200Response> {
        const response = await this.documentTypesQuickLabelsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the properties of the selected quick label.
     */
    async documentTypesQuickLabelsPartialUpdateRaw(requestParameters: DocumentTypesQuickLabelsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeQuickLabel>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesQuickLabelsPartialUpdate().'
            );
        }

        if (requestParameters['documentTypeQuickLabelId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeQuickLabelId',
                'Required parameter "documentTypeQuickLabelId" was null or undefined when calling documentTypesQuickLabelsPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesQuickLabelsPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/quick_labels/{document_type_quick_label_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));
        urlPath = urlPath.replace(`{${"document_type_quick_label_id"}}`, encodeURIComponent(String(requestParameters['documentTypeQuickLabelId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeQuickLabelToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeQuickLabelFromJSON(jsonValue));
    }

    /**
     * Edit the properties of the selected quick label.
     */
    async documentTypesQuickLabelsPartialUpdate(requestParameters: DocumentTypesQuickLabelsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeQuickLabel> {
        const response = await this.documentTypesQuickLabelsPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the selected quick label.
     */
    async documentTypesQuickLabelsReadRaw(requestParameters: DocumentTypesQuickLabelsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeQuickLabel>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesQuickLabelsRead().'
            );
        }

        if (requestParameters['documentTypeQuickLabelId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeQuickLabelId',
                'Required parameter "documentTypeQuickLabelId" was null or undefined when calling documentTypesQuickLabelsRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/quick_labels/{document_type_quick_label_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));
        urlPath = urlPath.replace(`{${"document_type_quick_label_id"}}`, encodeURIComponent(String(requestParameters['documentTypeQuickLabelId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeQuickLabelFromJSON(jsonValue));
    }

    /**
     * Return the details of the selected quick label.
     */
    async documentTypesQuickLabelsRead(requestParameters: DocumentTypesQuickLabelsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeQuickLabel> {
        const response = await this.documentTypesQuickLabelsReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the properties of the selected quick label.
     */
    async documentTypesQuickLabelsUpdateRaw(requestParameters: DocumentTypesQuickLabelsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTypeQuickLabel>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesQuickLabelsUpdate().'
            );
        }

        if (requestParameters['documentTypeQuickLabelId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeQuickLabelId',
                'Required parameter "documentTypeQuickLabelId" was null or undefined when calling documentTypesQuickLabelsUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesQuickLabelsUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/quick_labels/{document_type_quick_label_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));
        urlPath = urlPath.replace(`{${"document_type_quick_label_id"}}`, encodeURIComponent(String(requestParameters['documentTypeQuickLabelId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeQuickLabelToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeQuickLabelFromJSON(jsonValue));
    }

    /**
     * Edit the properties of the selected quick label.
     */
    async documentTypesQuickLabelsUpdate(requestParameters: DocumentTypesQuickLabelsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTypeQuickLabel> {
        const response = await this.documentTypesQuickLabelsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the selected document type.
     */
    async documentTypesReadRaw(requestParameters: DocumentTypesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentType>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeFromJSON(jsonValue));
    }

    /**
     * Return the details of the selected document type.
     */
    async documentTypesRead(requestParameters: DocumentTypesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentType> {
        const response = await this.documentTypesReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the properties of the selected document type.
     */
    async documentTypesUpdateRaw(requestParameters: DocumentTypesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentType>> {
        if (requestParameters['documentTypeId'] == null) {
            throw new runtime.RequiredError(
                'documentTypeId',
                'Required parameter "documentTypeId" was null or undefined when calling documentTypesUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentTypesUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/document_types/{document_type_id}/`;
        urlPath = urlPath.replace(`{${"document_type_id"}}`, encodeURIComponent(String(requestParameters['documentTypeId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTypeToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTypeFromJSON(jsonValue));
    }

    /**
     * Edit the properties of the selected document type.
     */
    async documentTypesUpdate(requestParameters: DocumentTypesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentType> {
        const response = await this.documentTypesUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
