/* tslint:disable */
/* eslint-disable */
/**
 * Mayan EDMS API
 * Free Open Source Electronic Document Management System
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CabinetsDocumentsList200Response,
  CabinetsList200Response,
  Comment,
  DetachedSignature,
  DetachedSignatureUpload,
  Document,
  DocumentChangeType,
  DocumentCheckout,
  DocumentFile,
  DocumentFileMetadataDriverEntry,
  DocumentFileMetadataEntry,
  DocumentFilePage,
  DocumentFilePageContent,
  DocumentFileSourceMetadata,
  DocumentMetadata,
  DocumentTagAttach,
  DocumentTagRemove,
  DocumentUpload,
  DocumentVersion,
  DocumentVersionModificationExecute,
  DocumentVersionPage,
  DocumentVersionPageOCRContent,
  DocumentsAccessedList200Response,
  DocumentsCommentsList200Response,
  DocumentsDuplicatesList200Response,
  DocumentsFavoritesList200Response,
  DocumentsFilesFileMetadataDriversEntriesList200Response,
  DocumentsFilesFileMetadataDriversList200Response,
  DocumentsFilesList200Response,
  DocumentsFilesPagesList200Response,
  DocumentsFilesSignaturesDetachedList200Response,
  DocumentsFilesSignaturesEmbeddedList200Response,
  DocumentsFilesSourceMetadataList200Response,
  DocumentsIndexesList200Response,
  DocumentsMetadataList200Response,
  DocumentsResolvedSmartLinksDocumentsList200Response,
  DocumentsResolvedSmartLinksList200Response,
  DocumentsResolvedWebLinksList200Response,
  DocumentsSignatureCapturesList200Response,
  DocumentsTagsList200Response,
  DocumentsVersionsList200Response,
  DocumentsVersionsPagesList200Response,
  DocumentsWorkflowInstancesList200Response,
  DocumentsWorkflowInstancesLogEntriesList200Response,
  DocumentsWorkflowInstancesLogEntriesTransitionsList200Response,
  EmbeddedSignature,
  FavoriteDocument,
  ResolvedSmartLink,
  ResolvedWebLink,
  SignDetached,
  SignEmbedded,
  SignatureCapture,
  WorkflowInstance,
  WorkflowInstanceLaunch,
  WorkflowInstanceLogEntry,
} from '../models/index';
import {
    CabinetsDocumentsList200ResponseFromJSON,
    CabinetsDocumentsList200ResponseToJSON,
    CabinetsList200ResponseFromJSON,
    CabinetsList200ResponseToJSON,
    CommentFromJSON,
    CommentToJSON,
    DetachedSignatureFromJSON,
    DetachedSignatureToJSON,
    DetachedSignatureUploadFromJSON,
    DetachedSignatureUploadToJSON,
    DocumentFromJSON,
    DocumentToJSON,
    DocumentChangeTypeFromJSON,
    DocumentChangeTypeToJSON,
    DocumentCheckoutFromJSON,
    DocumentCheckoutToJSON,
    DocumentFileFromJSON,
    DocumentFileToJSON,
    DocumentFileMetadataDriverEntryFromJSON,
    DocumentFileMetadataDriverEntryToJSON,
    DocumentFileMetadataEntryFromJSON,
    DocumentFileMetadataEntryToJSON,
    DocumentFilePageFromJSON,
    DocumentFilePageToJSON,
    DocumentFilePageContentFromJSON,
    DocumentFilePageContentToJSON,
    DocumentFileSourceMetadataFromJSON,
    DocumentFileSourceMetadataToJSON,
    DocumentMetadataFromJSON,
    DocumentMetadataToJSON,
    DocumentTagAttachFromJSON,
    DocumentTagAttachToJSON,
    DocumentTagRemoveFromJSON,
    DocumentTagRemoveToJSON,
    DocumentUploadFromJSON,
    DocumentUploadToJSON,
    DocumentVersionFromJSON,
    DocumentVersionToJSON,
    DocumentVersionModificationExecuteFromJSON,
    DocumentVersionModificationExecuteToJSON,
    DocumentVersionPageFromJSON,
    DocumentVersionPageToJSON,
    DocumentVersionPageOCRContentFromJSON,
    DocumentVersionPageOCRContentToJSON,
    DocumentsAccessedList200ResponseFromJSON,
    DocumentsAccessedList200ResponseToJSON,
    DocumentsCommentsList200ResponseFromJSON,
    DocumentsCommentsList200ResponseToJSON,
    DocumentsDuplicatesList200ResponseFromJSON,
    DocumentsDuplicatesList200ResponseToJSON,
    DocumentsFavoritesList200ResponseFromJSON,
    DocumentsFavoritesList200ResponseToJSON,
    DocumentsFilesFileMetadataDriversEntriesList200ResponseFromJSON,
    DocumentsFilesFileMetadataDriversEntriesList200ResponseToJSON,
    DocumentsFilesFileMetadataDriversList200ResponseFromJSON,
    DocumentsFilesFileMetadataDriversList200ResponseToJSON,
    DocumentsFilesList200ResponseFromJSON,
    DocumentsFilesList200ResponseToJSON,
    DocumentsFilesPagesList200ResponseFromJSON,
    DocumentsFilesPagesList200ResponseToJSON,
    DocumentsFilesSignaturesDetachedList200ResponseFromJSON,
    DocumentsFilesSignaturesDetachedList200ResponseToJSON,
    DocumentsFilesSignaturesEmbeddedList200ResponseFromJSON,
    DocumentsFilesSignaturesEmbeddedList200ResponseToJSON,
    DocumentsFilesSourceMetadataList200ResponseFromJSON,
    DocumentsFilesSourceMetadataList200ResponseToJSON,
    DocumentsIndexesList200ResponseFromJSON,
    DocumentsIndexesList200ResponseToJSON,
    DocumentsMetadataList200ResponseFromJSON,
    DocumentsMetadataList200ResponseToJSON,
    DocumentsResolvedSmartLinksDocumentsList200ResponseFromJSON,
    DocumentsResolvedSmartLinksDocumentsList200ResponseToJSON,
    DocumentsResolvedSmartLinksList200ResponseFromJSON,
    DocumentsResolvedSmartLinksList200ResponseToJSON,
    DocumentsResolvedWebLinksList200ResponseFromJSON,
    DocumentsResolvedWebLinksList200ResponseToJSON,
    DocumentsSignatureCapturesList200ResponseFromJSON,
    DocumentsSignatureCapturesList200ResponseToJSON,
    DocumentsTagsList200ResponseFromJSON,
    DocumentsTagsList200ResponseToJSON,
    DocumentsVersionsList200ResponseFromJSON,
    DocumentsVersionsList200ResponseToJSON,
    DocumentsVersionsPagesList200ResponseFromJSON,
    DocumentsVersionsPagesList200ResponseToJSON,
    DocumentsWorkflowInstancesList200ResponseFromJSON,
    DocumentsWorkflowInstancesList200ResponseToJSON,
    DocumentsWorkflowInstancesLogEntriesList200ResponseFromJSON,
    DocumentsWorkflowInstancesLogEntriesList200ResponseToJSON,
    DocumentsWorkflowInstancesLogEntriesTransitionsList200ResponseFromJSON,
    DocumentsWorkflowInstancesLogEntriesTransitionsList200ResponseToJSON,
    EmbeddedSignatureFromJSON,
    EmbeddedSignatureToJSON,
    FavoriteDocumentFromJSON,
    FavoriteDocumentToJSON,
    ResolvedSmartLinkFromJSON,
    ResolvedSmartLinkToJSON,
    ResolvedWebLinkFromJSON,
    ResolvedWebLinkToJSON,
    SignDetachedFromJSON,
    SignDetachedToJSON,
    SignEmbeddedFromJSON,
    SignEmbeddedToJSON,
    SignatureCaptureFromJSON,
    SignatureCaptureToJSON,
    WorkflowInstanceFromJSON,
    WorkflowInstanceToJSON,
    WorkflowInstanceLaunchFromJSON,
    WorkflowInstanceLaunchToJSON,
    WorkflowInstanceLogEntryFromJSON,
    WorkflowInstanceLogEntryToJSON,
} from '../models/index';

export interface DocumentsAccessedListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsCabinetsListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsCheckoutDeleteRequest {
    documentId: string;
}

export interface DocumentsCheckoutReadRequest {
    documentId: string;
}

export interface DocumentsCommentsCreateRequest {
    documentId: string;
    data: Omit<Comment, 'id'|'submit_date'|'url'>;
}

export interface DocumentsCommentsDeleteRequest {
    documentId: string;
    commentId: string;
}

export interface DocumentsCommentsListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsCommentsPartialUpdateRequest {
    documentId: string;
    commentId: string;
    data: Omit<Comment, 'id'|'submit_date'|'url'>;
}

export interface DocumentsCommentsReadRequest {
    documentId: string;
    commentId: string;
}

export interface DocumentsCommentsUpdateRequest {
    documentId: string;
    commentId: string;
    data: Omit<Comment, 'id'|'submit_date'|'url'>;
}

export interface DocumentsCreateRequest {
    data: Omit<Document, 'datetime_created'|'document_change_type_url'|'file_list_url'|'id'|'url'|'uuid'|'version_list_url'>;
}

export interface DocumentsCreatedListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsDeleteRequest {
    documentId: string;
}

export interface DocumentsDuplicatedListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsDuplicatesListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsFavoritesCreateRequest {
    data: Omit<FavoriteDocument, 'datetime_added'|'id'|'url'>;
}

export interface DocumentsFavoritesDeleteRequest {
    favoriteDocumentId: string;
}

export interface DocumentsFavoritesListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsFavoritesReadRequest {
    favoriteDocumentId: string;
}

export interface DocumentsFilesCreateRequest {
    documentId: string;
    data: Omit<DocumentFile, 'checksum'|'document_id'|'document_url'|'encoding'|'file'|'id'|'mimetype'|'page_list_url'|'size'|'timestamp'|'url'>;
}

export interface DocumentsFilesDeleteRequest {
    documentId: string;
    documentFileId: string;
}

export interface DocumentsFilesDownloadReadRequest {
    documentId: string;
    documentFileId: string;
}

export interface DocumentsFilesFileMetadataDriversEntriesListRequest {
    documentId: string;
    documentFileId: string;
    driverId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsFilesFileMetadataDriversEntriesReadRequest {
    documentId: string;
    documentFileId: string;
    driverId: string;
    entryId: string;
}

export interface DocumentsFilesFileMetadataDriversListRequest {
    documentId: string;
    documentFileId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsFilesFileMetadataDriversReadRequest {
    documentId: string;
    documentFileId: string;
    driverId: string;
}

export interface DocumentsFilesFileMetadataSubmitCreateRequest {
    documentId: string;
    documentFileId: string;
    data: object;
}

export interface DocumentsFilesListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsFilesPagesContentReadRequest {
    documentId: string;
    documentFileId: string;
    documentFilePageId: string;
}

export interface DocumentsFilesPagesImageReadRequest {
    documentId: string;
    documentFileId: string;
    documentFilePageId: string;
}

export interface DocumentsFilesPagesListRequest {
    documentId: string;
    documentFileId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsFilesPagesReadRequest {
    documentId: string;
    documentFileId: string;
    documentFilePageId: string;
}

export interface DocumentsFilesPartialUpdateRequest {
    documentId: string;
    documentFileId: string;
    data: Omit<DocumentFile, 'checksum'|'document_id'|'document_url'|'encoding'|'file'|'id'|'mimetype'|'page_list_url'|'size'|'timestamp'|'url'>;
}

export interface DocumentsFilesReadRequest {
    documentId: string;
    documentFileId: string;
}

export interface DocumentsFilesSignaturesDetachedDeleteRequest {
    documentId: string;
    documentFileId: string;
    detachedSignatureId: string;
}

export interface DocumentsFilesSignaturesDetachedListRequest {
    documentId: string;
    documentFileId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsFilesSignaturesDetachedReadRequest {
    documentId: string;
    documentFileId: string;
    detachedSignatureId: string;
}

export interface DocumentsFilesSignaturesDetachedSignCreateRequest {
    documentId: string;
    documentFileId: string;
    data: SignDetached;
}

export interface DocumentsFilesSignaturesDetachedUploadCreateRequest {
    documentId: string;
    documentFileId: string;
    data: Omit<DetachedSignatureUpload, 'date_time'|'document_file_url'|'key_algorithm'|'key_creation_date'|'key_expiration_date'|'key_id'|'key_length'|'key_type'|'key_user_id'|'key_url'|'public_key_fingerprint'|'signature_id'|'url'|'signature_file'>;
}

export interface DocumentsFilesSignaturesEmbeddedListRequest {
    documentId: string;
    documentFileId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsFilesSignaturesEmbeddedReadRequest {
    documentId: string;
    documentFileId: string;
    embeddedSignatureId: string;
}

export interface DocumentsFilesSignaturesEmbeddedSignCreateRequest {
    documentId: string;
    documentFileId: string;
    data: SignEmbedded;
}

export interface DocumentsFilesSourceMetadataListRequest {
    documentId: string;
    documentFileId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsFilesSourceMetadataReadRequest {
    documentId: string;
    documentFileId: string;
    documentFileSourceMetadataId: string;
}

export interface DocumentsFilesUpdateRequest {
    documentId: string;
    documentFileId: string;
    data: Omit<DocumentFile, 'checksum'|'document_id'|'document_url'|'encoding'|'file'|'id'|'mimetype'|'page_list_url'|'size'|'timestamp'|'url'>;
}

export interface DocumentsIndexesListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsMetadataCreateRequest {
    documentId: string;
    data: Omit<DocumentMetadata, 'id'|'url'>;
}

export interface DocumentsMetadataDeleteRequest {
    documentId: string;
    metadataId: string;
}

export interface DocumentsMetadataListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsMetadataPartialUpdateRequest {
    documentId: string;
    metadataId: string;
    data: Omit<DocumentMetadata, 'id'|'url'>;
}

export interface DocumentsMetadataReadRequest {
    documentId: string;
    metadataId: string;
}

export interface DocumentsMetadataUpdateRequest {
    documentId: string;
    metadataId: string;
    data: Omit<DocumentMetadata, 'id'|'url'>;
}

export interface DocumentsOcrSubmitCreateRequest {
    documentId: string;
}

export interface DocumentsPartialUpdateRequest {
    documentId: string;
    data: Omit<Document, 'datetime_created'|'document_change_type_url'|'file_list_url'|'id'|'url'|'uuid'|'version_list_url'>;
}

export interface DocumentsReadRequest {
    documentId: string;
}

export interface DocumentsResolvedSmartLinksDocumentsListRequest {
    documentId: string;
    resolvedSmartLinkId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsResolvedSmartLinksListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsResolvedSmartLinksReadRequest {
    documentId: string;
    resolvedSmartLinkId: string;
}

export interface DocumentsResolvedWebLinksListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsResolvedWebLinksNavigateReadRequest {
    documentId: string;
    resolvedWebLinkId: string;
}

export interface DocumentsResolvedWebLinksReadRequest {
    documentId: string;
    resolvedWebLinkId: string;
}

export interface DocumentsSignatureCapturesCreateRequest {
    documentId: string;
    data: Omit<SignatureCapture, 'document_id'|'document_url'|'id'|'image_url'|'url'>;
}

export interface DocumentsSignatureCapturesDeleteRequest {
    documentId: string;
    signatureCaptureId: string;
}

export interface DocumentsSignatureCapturesImageReadRequest {
    documentId: string;
    signatureCaptureId: string;
}

export interface DocumentsSignatureCapturesListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsSignatureCapturesPartialUpdateRequest {
    documentId: string;
    signatureCaptureId: string;
    data: Omit<SignatureCapture, 'document_id'|'document_url'|'id'|'image_url'|'url'>;
}

export interface DocumentsSignatureCapturesReadRequest {
    documentId: string;
    signatureCaptureId: string;
}

export interface DocumentsSignatureCapturesUpdateRequest {
    documentId: string;
    signatureCaptureId: string;
    data: Omit<SignatureCapture, 'document_id'|'document_url'|'id'|'image_url'|'url'>;
}

export interface DocumentsTagsAttachCreateRequest {
    documentId: string;
    data: DocumentTagAttach;
}

export interface DocumentsTagsListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsTagsRemoveCreateRequest {
    documentId: string;
    data: DocumentTagRemove;
}

export interface DocumentsTypeChangeCreateRequest {
    documentId: string;
    data: DocumentChangeType;
}

export interface DocumentsUpdateRequest {
    documentId: string;
    data: Omit<Document, 'datetime_created'|'document_change_type_url'|'file_list_url'|'id'|'url'|'uuid'|'version_list_url'>;
}

export interface DocumentsUploadCreateRequest {
    data: Omit<DocumentUpload, 'datetime_created'|'document_change_type_url'|'file_list_url'|'id'|'pk'|'url'|'uuid'|'version_list_url'>;
}

export interface DocumentsVersionsCreateRequest {
    documentId: string;
    data: Omit<DocumentVersion, 'document_id'|'document_url'|'export_url'|'id'|'page_list_url'|'timestamp'|'url'>;
}

export interface DocumentsVersionsDeleteRequest {
    documentId: string;
    documentVersionId: string;
}

export interface DocumentsVersionsExportCreateRequest {
    documentId: string;
    documentVersionId: string;
    data: object;
}

export interface DocumentsVersionsListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsVersionsModifyCreateRequest {
    documentId: string;
    documentVersionId: string;
    data: DocumentVersionModificationExecute;
}

export interface DocumentsVersionsOcrSubmitCreateRequest {
    documentId: string;
    documentVersionId: string;
}

export interface DocumentsVersionsPagesCreateRequest {
    documentId: string;
    documentVersionId: string;
    data: Omit<DocumentVersionPage, 'document_version_id'|'document_version_url'|'id'|'image_url'|'url'>;
}

export interface DocumentsVersionsPagesDeleteRequest {
    documentId: string;
    documentVersionId: string;
    documentVersionPageId: string;
}

export interface DocumentsVersionsPagesImageReadRequest {
    documentId: string;
    documentVersionId: string;
    documentVersionPageId: string;
}

export interface DocumentsVersionsPagesListRequest {
    documentId: string;
    documentVersionId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsVersionsPagesOcrPartialUpdateRequest {
    documentId: string;
    documentVersionId: string;
    documentVersionPageId: string;
    data: DocumentVersionPageOCRContent;
}

export interface DocumentsVersionsPagesOcrReadRequest {
    documentId: string;
    documentVersionId: string;
    documentVersionPageId: string;
}

export interface DocumentsVersionsPagesOcrUpdateRequest {
    documentId: string;
    documentVersionId: string;
    documentVersionPageId: string;
    data: DocumentVersionPageOCRContent;
}

export interface DocumentsVersionsPagesPartialUpdateRequest {
    documentId: string;
    documentVersionId: string;
    documentVersionPageId: string;
    data: Omit<DocumentVersionPage, 'document_version_id'|'document_version_url'|'id'|'image_url'|'url'>;
}

export interface DocumentsVersionsPagesReadRequest {
    documentId: string;
    documentVersionId: string;
    documentVersionPageId: string;
}

export interface DocumentsVersionsPagesUpdateRequest {
    documentId: string;
    documentVersionId: string;
    documentVersionPageId: string;
    data: Omit<DocumentVersionPage, 'document_version_id'|'document_version_url'|'id'|'image_url'|'url'>;
}

export interface DocumentsVersionsPartialUpdateRequest {
    documentId: string;
    documentVersionId: string;
    data: Omit<DocumentVersion, 'document_id'|'document_url'|'export_url'|'id'|'page_list_url'|'timestamp'|'url'>;
}

export interface DocumentsVersionsReadRequest {
    documentId: string;
    documentVersionId: string;
}

export interface DocumentsVersionsUpdateRequest {
    documentId: string;
    documentVersionId: string;
    data: Omit<DocumentVersion, 'document_id'|'document_url'|'export_url'|'id'|'page_list_url'|'timestamp'|'url'>;
}

export interface DocumentsWorkflowInstancesLaunchCreateRequest {
    documentId: string;
    data: WorkflowInstanceLaunch;
}

export interface DocumentsWorkflowInstancesListRequest {
    documentId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsWorkflowInstancesLogEntriesCreateRequest {
    documentId: string;
    workflowInstanceId: string;
    data: Omit<WorkflowInstanceLogEntry, 'datetime'|'document_url'|'id'|'url'|'workflow_instance_url'|'workflow_template_url'>;
}

export interface DocumentsWorkflowInstancesLogEntriesListRequest {
    documentId: string;
    workflowInstanceId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsWorkflowInstancesLogEntriesReadRequest {
    documentId: string;
    workflowInstanceId: string;
    workflowInstanceLogEntryId: string;
}

export interface DocumentsWorkflowInstancesLogEntriesTransitionsListRequest {
    documentId: string;
    workflowInstanceId: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
}

export interface DocumentsWorkflowInstancesReadRequest {
    documentId: string;
    workflowInstanceId: string;
}

/**
 * 
 */
export class DocumentsApi extends runtime.BaseAPI {

    /**
     * Return a list of the recently accessed documents for the current user.
     */
    async documentsAccessedListRaw(requestParameters: DocumentsAccessedListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsAccessedList200Response>> {
        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/accessed/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsAccessedList200ResponseFromJSON(jsonValue));
    }

    /**
     * Return a list of the recently accessed documents for the current user.
     */
    async documentsAccessedList(requestParameters: DocumentsAccessedListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsAccessedList200Response> {
        const response = await this.documentsAccessedListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all the cabinets to which a document belongs.
     */
    async documentsCabinetsListRaw(requestParameters: DocumentsCabinetsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CabinetsList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsCabinetsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/cabinets/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CabinetsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the cabinets to which a document belongs.
     */
    async documentsCabinetsList(requestParameters: DocumentsCabinetsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CabinetsList200Response> {
        const response = await this.documentsCabinetsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check in the selected document.
     */
    async documentsCheckoutDeleteRaw(requestParameters: DocumentsCheckoutDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsCheckoutDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/checkout/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Check in the selected document.
     */
    async documentsCheckoutDelete(requestParameters: DocumentsCheckoutDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsCheckoutDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve the checkout details of the selected document entry.
     */
    async documentsCheckoutReadRaw(requestParameters: DocumentsCheckoutReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentCheckout>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsCheckoutRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/checkout/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentCheckoutFromJSON(jsonValue));
    }

    /**
     * Retrieve the checkout details of the selected document entry.
     */
    async documentsCheckoutRead(requestParameters: DocumentsCheckoutReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentCheckout> {
        const response = await this.documentsCheckoutReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new document comment.
     */
    async documentsCommentsCreateRaw(requestParameters: DocumentsCommentsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsCommentsCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsCommentsCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/comments/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CommentToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Create a new document comment.
     */
    async documentsCommentsCreate(requestParameters: DocumentsCommentsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Comment> {
        const response = await this.documentsCommentsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the selected document comment.
     */
    async documentsCommentsDeleteRaw(requestParameters: DocumentsCommentsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsCommentsDelete().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling documentsCommentsDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/comments/{comment_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"comment_id"}}`, encodeURIComponent(String(requestParameters['commentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the selected document comment.
     */
    async documentsCommentsDelete(requestParameters: DocumentsCommentsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsCommentsDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a list of all the document comments.
     */
    async documentsCommentsListRaw(requestParameters: DocumentsCommentsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsCommentsList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsCommentsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/comments/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsCommentsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the document comments.
     */
    async documentsCommentsList(requestParameters: DocumentsCommentsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsCommentsList200Response> {
        const response = await this.documentsCommentsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async documentsCommentsPartialUpdateRaw(requestParameters: DocumentsCommentsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsCommentsPartialUpdate().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling documentsCommentsPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsCommentsPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/comments/{comment_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"comment_id"}}`, encodeURIComponent(String(requestParameters['commentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: CommentToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     */
    async documentsCommentsPartialUpdate(requestParameters: DocumentsCommentsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Comment> {
        const response = await this.documentsCommentsPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the details of the selected document comment.
     */
    async documentsCommentsReadRaw(requestParameters: DocumentsCommentsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsCommentsRead().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling documentsCommentsRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/comments/{comment_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"comment_id"}}`, encodeURIComponent(String(requestParameters['commentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     * Returns the details of the selected document comment.
     */
    async documentsCommentsRead(requestParameters: DocumentsCommentsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Comment> {
        const response = await this.documentsCommentsReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async documentsCommentsUpdateRaw(requestParameters: DocumentsCommentsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Comment>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsCommentsUpdate().'
            );
        }

        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling documentsCommentsUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsCommentsUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/comments/{comment_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"comment_id"}}`, encodeURIComponent(String(requestParameters['commentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CommentToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CommentFromJSON(jsonValue));
    }

    /**
     */
    async documentsCommentsUpdate(requestParameters: DocumentsCommentsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Comment> {
        const response = await this.documentsCommentsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new document.
     */
    async documentsCreateRaw(requestParameters: DocumentsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Create a new document.
     */
    async documentsCreate(requestParameters: DocumentsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.documentsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of the recently created documents.
     */
    async documentsCreatedListRaw(requestParameters: DocumentsCreatedListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CabinetsDocumentsList200Response>> {
        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/created/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CabinetsDocumentsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Return a list of the recently created documents.
     */
    async documentsCreatedList(requestParameters: DocumentsCreatedListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CabinetsDocumentsList200Response> {
        const response = await this.documentsCreatedListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move the selected document to the thrash.
     */
    async documentsDeleteRaw(requestParameters: DocumentsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Move the selected document to the thrash.
     */
    async documentsDelete(requestParameters: DocumentsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Return a list of duplicated documents.
     */
    async documentsDuplicatedListRaw(requestParameters: DocumentsDuplicatedListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CabinetsDocumentsList200Response>> {
        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/duplicated/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CabinetsDocumentsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Return a list of duplicated documents.
     */
    async documentsDuplicatedList(requestParameters: DocumentsDuplicatedListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CabinetsDocumentsList200Response> {
        const response = await this.documentsDuplicatedListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of the selected document\'s duplicates.
     */
    async documentsDuplicatesListRaw(requestParameters: DocumentsDuplicatesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsDuplicatesList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsDuplicatesList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/duplicates/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsDuplicatesList200ResponseFromJSON(jsonValue));
    }

    /**
     * Return a list of the selected document\'s duplicates.
     */
    async documentsDuplicatesList(requestParameters: DocumentsDuplicatesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsDuplicatesList200Response> {
        const response = await this.documentsDuplicatesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new document to the list of favorite documents for the current user.
     */
    async documentsFavoritesCreateRaw(requestParameters: DocumentsFavoritesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FavoriteDocument>> {
        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsFavoritesCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/favorites/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FavoriteDocumentToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FavoriteDocumentFromJSON(jsonValue));
    }

    /**
     * Add a new document to the list of favorite documents for the current user.
     */
    async documentsFavoritesCreate(requestParameters: DocumentsFavoritesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FavoriteDocument> {
        const response = await this.documentsFavoritesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the selected favorite document.
     */
    async documentsFavoritesDeleteRaw(requestParameters: DocumentsFavoritesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['favoriteDocumentId'] == null) {
            throw new runtime.RequiredError(
                'favoriteDocumentId',
                'Required parameter "favoriteDocumentId" was null or undefined when calling documentsFavoritesDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/favorites/{favorite_document_id}/`;
        urlPath = urlPath.replace(`{${"favorite_document_id"}}`, encodeURIComponent(String(requestParameters['favoriteDocumentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the selected favorite document.
     */
    async documentsFavoritesDelete(requestParameters: DocumentsFavoritesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsFavoritesDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Return a list of the favorite documents for the current user.
     */
    async documentsFavoritesListRaw(requestParameters: DocumentsFavoritesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsFavoritesList200Response>> {
        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/favorites/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsFavoritesList200ResponseFromJSON(jsonValue));
    }

    /**
     * Return a list of the favorite documents for the current user.
     */
    async documentsFavoritesList(requestParameters: DocumentsFavoritesListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsFavoritesList200Response> {
        const response = await this.documentsFavoritesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the selected favorite document.
     */
    async documentsFavoritesReadRaw(requestParameters: DocumentsFavoritesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FavoriteDocument>> {
        if (requestParameters['favoriteDocumentId'] == null) {
            throw new runtime.RequiredError(
                'favoriteDocumentId',
                'Required parameter "favoriteDocumentId" was null or undefined when calling documentsFavoritesRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/favorites/{favorite_document_id}/`;
        urlPath = urlPath.replace(`{${"favorite_document_id"}}`, encodeURIComponent(String(requestParameters['favoriteDocumentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FavoriteDocumentFromJSON(jsonValue));
    }

    /**
     * Return the details of the selected favorite document.
     */
    async documentsFavoritesRead(requestParameters: DocumentsFavoritesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FavoriteDocument> {
        const response = await this.documentsFavoritesReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new document file.
     */
    async documentsFilesCreateRaw(requestParameters: DocumentsFilesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentFile>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsFilesCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentFileToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFileFromJSON(jsonValue));
    }

    /**
     * Create a new document file.
     */
    async documentsFilesCreate(requestParameters: DocumentsFilesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentFile> {
        const response = await this.documentsFilesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the selected document file.
     */
    async documentsFilesDeleteRaw(requestParameters: DocumentsFilesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesDelete().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the selected document file.
     */
    async documentsFilesDelete(requestParameters: DocumentsFilesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsFilesDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Download a document file.
     */
    async documentsFilesDownloadReadRaw(requestParameters: DocumentsFilesDownloadReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesDownloadRead().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesDownloadRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/download/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Download a document file.
     */
    async documentsFilesDownloadRead(requestParameters: DocumentsFilesDownloadReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsFilesDownloadReadRaw(requestParameters, initOverrides);
    }

    /**
     * Return the list of file metadata entries for the selected driver.
     */
    async documentsFilesFileMetadataDriversEntriesListRaw(requestParameters: DocumentsFilesFileMetadataDriversEntriesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsFilesFileMetadataDriversEntriesList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesFileMetadataDriversEntriesList().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesFileMetadataDriversEntriesList().'
            );
        }

        if (requestParameters['driverId'] == null) {
            throw new runtime.RequiredError(
                'driverId',
                'Required parameter "driverId" was null or undefined when calling documentsFilesFileMetadataDriversEntriesList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/file_metadata/drivers/{driver_id}/entries/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));
        urlPath = urlPath.replace(`{${"driver_id"}}`, encodeURIComponent(String(requestParameters['driverId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsFilesFileMetadataDriversEntriesList200ResponseFromJSON(jsonValue));
    }

    /**
     * Return the list of file metadata entries for the selected driver.
     */
    async documentsFilesFileMetadataDriversEntriesList(requestParameters: DocumentsFilesFileMetadataDriversEntriesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsFilesFileMetadataDriversEntriesList200Response> {
        const response = await this.documentsFilesFileMetadataDriversEntriesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the detail of selected document file metadata entry.
     */
    async documentsFilesFileMetadataDriversEntriesReadRaw(requestParameters: DocumentsFilesFileMetadataDriversEntriesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentFileMetadataEntry>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesFileMetadataDriversEntriesRead().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesFileMetadataDriversEntriesRead().'
            );
        }

        if (requestParameters['driverId'] == null) {
            throw new runtime.RequiredError(
                'driverId',
                'Required parameter "driverId" was null or undefined when calling documentsFilesFileMetadataDriversEntriesRead().'
            );
        }

        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling documentsFilesFileMetadataDriversEntriesRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/file_metadata/drivers/{driver_id}/entries/{entry_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));
        urlPath = urlPath.replace(`{${"driver_id"}}`, encodeURIComponent(String(requestParameters['driverId'])));
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFileMetadataEntryFromJSON(jsonValue));
    }

    /**
     * Return the detail of selected document file metadata entry.
     */
    async documentsFilesFileMetadataDriversEntriesRead(requestParameters: DocumentsFilesFileMetadataDriversEntriesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentFileMetadataEntry> {
        const response = await this.documentsFilesFileMetadataDriversEntriesReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of selected document\'s file metadata drivers.
     */
    async documentsFilesFileMetadataDriversListRaw(requestParameters: DocumentsFilesFileMetadataDriversListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsFilesFileMetadataDriversList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesFileMetadataDriversList().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesFileMetadataDriversList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/file_metadata/drivers/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsFilesFileMetadataDriversList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of selected document\'s file metadata drivers.
     */
    async documentsFilesFileMetadataDriversList(requestParameters: DocumentsFilesFileMetadataDriversListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsFilesFileMetadataDriversList200Response> {
        const response = await this.documentsFilesFileMetadataDriversListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the details of the document file metadata driver.
     */
    async documentsFilesFileMetadataDriversReadRaw(requestParameters: DocumentsFilesFileMetadataDriversReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentFileMetadataDriverEntry>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesFileMetadataDriversRead().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesFileMetadataDriversRead().'
            );
        }

        if (requestParameters['driverId'] == null) {
            throw new runtime.RequiredError(
                'driverId',
                'Required parameter "driverId" was null or undefined when calling documentsFilesFileMetadataDriversRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/file_metadata/drivers/{driver_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));
        urlPath = urlPath.replace(`{${"driver_id"}}`, encodeURIComponent(String(requestParameters['driverId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFileMetadataDriverEntryFromJSON(jsonValue));
    }

    /**
     * Returns the details of the document file metadata driver.
     */
    async documentsFilesFileMetadataDriversRead(requestParameters: DocumentsFilesFileMetadataDriversReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentFileMetadataDriverEntry> {
        const response = await this.documentsFilesFileMetadataDriversReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Submit a document file for file metadata processing.
     */
    async documentsFilesFileMetadataSubmitCreateRaw(requestParameters: DocumentsFilesFileMetadataSubmitCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesFileMetadataSubmitCreate().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesFileMetadataSubmitCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsFilesFileMetadataSubmitCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/file_metadata/submit/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['data'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Submit a document file for file metadata processing.
     */
    async documentsFilesFileMetadataSubmitCreate(requestParameters: DocumentsFilesFileMetadataSubmitCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.documentsFilesFileMetadataSubmitCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of the selected document\'s files.
     */
    async documentsFilesListRaw(requestParameters: DocumentsFilesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsFilesList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsFilesList200ResponseFromJSON(jsonValue));
    }

    /**
     * Return a list of the selected document\'s files.
     */
    async documentsFilesList(requestParameters: DocumentsFilesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsFilesList200Response> {
        const response = await this.documentsFilesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the content of the selected document page.
     */
    async documentsFilesPagesContentReadRaw(requestParameters: DocumentsFilesPagesContentReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentFilePageContent>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesPagesContentRead().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesPagesContentRead().'
            );
        }

        if (requestParameters['documentFilePageId'] == null) {
            throw new runtime.RequiredError(
                'documentFilePageId',
                'Required parameter "documentFilePageId" was null or undefined when calling documentsFilesPagesContentRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/pages/{document_file_page_id}/content/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));
        urlPath = urlPath.replace(`{${"document_file_page_id"}}`, encodeURIComponent(String(requestParameters['documentFilePageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFilePageContentFromJSON(jsonValue));
    }

    /**
     * Returns the content of the selected document page.
     */
    async documentsFilesPagesContentRead(requestParameters: DocumentsFilesPagesContentReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentFilePageContent> {
        const response = await this.documentsFilesPagesContentReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an image representation of the selected document.
     */
    async documentsFilesPagesImageReadRaw(requestParameters: DocumentsFilesPagesImageReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesPagesImageRead().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesPagesImageRead().'
            );
        }

        if (requestParameters['documentFilePageId'] == null) {
            throw new runtime.RequiredError(
                'documentFilePageId',
                'Required parameter "documentFilePageId" was null or undefined when calling documentsFilesPagesImageRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/pages/{document_file_page_id}/image/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));
        urlPath = urlPath.replace(`{${"document_file_page_id"}}`, encodeURIComponent(String(requestParameters['documentFilePageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns an image representation of the selected document.
     */
    async documentsFilesPagesImageRead(requestParameters: DocumentsFilesPagesImageReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsFilesPagesImageReadRaw(requestParameters, initOverrides);
    }

    /**
     */
    async documentsFilesPagesListRaw(requestParameters: DocumentsFilesPagesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsFilesPagesList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesPagesList().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesPagesList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/pages/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsFilesPagesList200ResponseFromJSON(jsonValue));
    }

    /**
     */
    async documentsFilesPagesList(requestParameters: DocumentsFilesPagesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsFilesPagesList200Response> {
        const response = await this.documentsFilesPagesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the selected document page details.
     */
    async documentsFilesPagesReadRaw(requestParameters: DocumentsFilesPagesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentFilePage>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesPagesRead().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesPagesRead().'
            );
        }

        if (requestParameters['documentFilePageId'] == null) {
            throw new runtime.RequiredError(
                'documentFilePageId',
                'Required parameter "documentFilePageId" was null or undefined when calling documentsFilesPagesRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/pages/{document_file_page_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));
        urlPath = urlPath.replace(`{${"document_file_page_id"}}`, encodeURIComponent(String(requestParameters['documentFilePageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFilePageFromJSON(jsonValue));
    }

    /**
     * Returns the selected document page details.
     */
    async documentsFilesPagesRead(requestParameters: DocumentsFilesPagesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentFilePage> {
        const response = await this.documentsFilesPagesReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async documentsFilesPartialUpdateRaw(requestParameters: DocumentsFilesPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentFile>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesPartialUpdate().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsFilesPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentFileToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFileFromJSON(jsonValue));
    }

    /**
     */
    async documentsFilesPartialUpdate(requestParameters: DocumentsFilesPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentFile> {
        const response = await this.documentsFilesPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the selected document file details.
     */
    async documentsFilesReadRaw(requestParameters: DocumentsFilesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentFile>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesRead().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFileFromJSON(jsonValue));
    }

    /**
     * Returns the selected document file details.
     */
    async documentsFilesRead(requestParameters: DocumentsFilesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentFile> {
        const response = await this.documentsFilesReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an detached signature of the selected document.
     */
    async documentsFilesSignaturesDetachedDeleteRaw(requestParameters: DocumentsFilesSignaturesDetachedDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesSignaturesDetachedDelete().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesSignaturesDetachedDelete().'
            );
        }

        if (requestParameters['detachedSignatureId'] == null) {
            throw new runtime.RequiredError(
                'detachedSignatureId',
                'Required parameter "detachedSignatureId" was null or undefined when calling documentsFilesSignaturesDetachedDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/signatures/detached/{detached_signature_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));
        urlPath = urlPath.replace(`{${"detached_signature_id"}}`, encodeURIComponent(String(requestParameters['detachedSignatureId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an detached signature of the selected document.
     */
    async documentsFilesSignaturesDetachedDelete(requestParameters: DocumentsFilesSignaturesDetachedDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsFilesSignaturesDetachedDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a list of all the detached signatures of a document file.
     */
    async documentsFilesSignaturesDetachedListRaw(requestParameters: DocumentsFilesSignaturesDetachedListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsFilesSignaturesDetachedList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesSignaturesDetachedList().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesSignaturesDetachedList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/signatures/detached/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsFilesSignaturesDetachedList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the detached signatures of a document file.
     */
    async documentsFilesSignaturesDetachedList(requestParameters: DocumentsFilesSignaturesDetachedListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsFilesSignaturesDetachedList200Response> {
        const response = await this.documentsFilesSignaturesDetachedListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the details of the selected detached signature.
     */
    async documentsFilesSignaturesDetachedReadRaw(requestParameters: DocumentsFilesSignaturesDetachedReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DetachedSignature>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesSignaturesDetachedRead().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesSignaturesDetachedRead().'
            );
        }

        if (requestParameters['detachedSignatureId'] == null) {
            throw new runtime.RequiredError(
                'detachedSignatureId',
                'Required parameter "detachedSignatureId" was null or undefined when calling documentsFilesSignaturesDetachedRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/signatures/detached/{detached_signature_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));
        urlPath = urlPath.replace(`{${"detached_signature_id"}}`, encodeURIComponent(String(requestParameters['detachedSignatureId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DetachedSignatureFromJSON(jsonValue));
    }

    /**
     * Returns the details of the selected detached signature.
     */
    async documentsFilesSignaturesDetachedRead(requestParameters: DocumentsFilesSignaturesDetachedReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DetachedSignature> {
        const response = await this.documentsFilesSignaturesDetachedReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sign a document file with a detached signature.
     */
    async documentsFilesSignaturesDetachedSignCreateRaw(requestParameters: DocumentsFilesSignaturesDetachedSignCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SignDetached>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesSignaturesDetachedSignCreate().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesSignaturesDetachedSignCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsFilesSignaturesDetachedSignCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/signatures/detached/sign/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SignDetachedToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SignDetachedFromJSON(jsonValue));
    }

    /**
     * Sign a document file with a detached signature.
     */
    async documentsFilesSignaturesDetachedSignCreate(requestParameters: DocumentsFilesSignaturesDetachedSignCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SignDetached> {
        const response = await this.documentsFilesSignaturesDetachedSignCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a detached signature file for a document file.
     */
    async documentsFilesSignaturesDetachedUploadCreateRaw(requestParameters: DocumentsFilesSignaturesDetachedUploadCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DetachedSignatureUpload>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesSignaturesDetachedUploadCreate().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesSignaturesDetachedUploadCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsFilesSignaturesDetachedUploadCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/signatures/detached/upload/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DetachedSignatureUploadToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DetachedSignatureUploadFromJSON(jsonValue));
    }

    /**
     * Upload a detached signature file for a document file.
     */
    async documentsFilesSignaturesDetachedUploadCreate(requestParameters: DocumentsFilesSignaturesDetachedUploadCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DetachedSignatureUpload> {
        const response = await this.documentsFilesSignaturesDetachedUploadCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all the embedded signatures of a document file.
     */
    async documentsFilesSignaturesEmbeddedListRaw(requestParameters: DocumentsFilesSignaturesEmbeddedListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsFilesSignaturesEmbeddedList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesSignaturesEmbeddedList().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesSignaturesEmbeddedList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/signatures/embedded/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsFilesSignaturesEmbeddedList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the embedded signatures of a document file.
     */
    async documentsFilesSignaturesEmbeddedList(requestParameters: DocumentsFilesSignaturesEmbeddedListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsFilesSignaturesEmbeddedList200Response> {
        const response = await this.documentsFilesSignaturesEmbeddedListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the details of the selected embedded signature.
     */
    async documentsFilesSignaturesEmbeddedReadRaw(requestParameters: DocumentsFilesSignaturesEmbeddedReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EmbeddedSignature>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesSignaturesEmbeddedRead().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesSignaturesEmbeddedRead().'
            );
        }

        if (requestParameters['embeddedSignatureId'] == null) {
            throw new runtime.RequiredError(
                'embeddedSignatureId',
                'Required parameter "embeddedSignatureId" was null or undefined when calling documentsFilesSignaturesEmbeddedRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/signatures/embedded/{embedded_signature_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));
        urlPath = urlPath.replace(`{${"embedded_signature_id"}}`, encodeURIComponent(String(requestParameters['embeddedSignatureId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EmbeddedSignatureFromJSON(jsonValue));
    }

    /**
     * Returns the details of the selected embedded signature.
     */
    async documentsFilesSignaturesEmbeddedRead(requestParameters: DocumentsFilesSignaturesEmbeddedReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EmbeddedSignature> {
        const response = await this.documentsFilesSignaturesEmbeddedReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sign a document file with an embedded signature.
     */
    async documentsFilesSignaturesEmbeddedSignCreateRaw(requestParameters: DocumentsFilesSignaturesEmbeddedSignCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SignEmbedded>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesSignaturesEmbeddedSignCreate().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesSignaturesEmbeddedSignCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsFilesSignaturesEmbeddedSignCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/signatures/embedded/sign/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SignEmbeddedToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SignEmbeddedFromJSON(jsonValue));
    }

    /**
     * Sign a document file with an embedded signature.
     */
    async documentsFilesSignaturesEmbeddedSignCreate(requestParameters: DocumentsFilesSignaturesEmbeddedSignCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SignEmbedded> {
        const response = await this.documentsFilesSignaturesEmbeddedSignCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of selected document\'s source metadata values.
     */
    async documentsFilesSourceMetadataListRaw(requestParameters: DocumentsFilesSourceMetadataListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsFilesSourceMetadataList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesSourceMetadataList().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesSourceMetadataList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/source_metadata/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsFilesSourceMetadataList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of selected document\'s source metadata values.
     */
    async documentsFilesSourceMetadataList(requestParameters: DocumentsFilesSourceMetadataListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsFilesSourceMetadataList200Response> {
        const response = await this.documentsFilesSourceMetadataListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the selected document source metadata.
     */
    async documentsFilesSourceMetadataReadRaw(requestParameters: DocumentsFilesSourceMetadataReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentFileSourceMetadata>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesSourceMetadataRead().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesSourceMetadataRead().'
            );
        }

        if (requestParameters['documentFileSourceMetadataId'] == null) {
            throw new runtime.RequiredError(
                'documentFileSourceMetadataId',
                'Required parameter "documentFileSourceMetadataId" was null or undefined when calling documentsFilesSourceMetadataRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/source_metadata/{document_file_source_metadata_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));
        urlPath = urlPath.replace(`{${"document_file_source_metadata_id"}}`, encodeURIComponent(String(requestParameters['documentFileSourceMetadataId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFileSourceMetadataFromJSON(jsonValue));
    }

    /**
     * Return the details of the selected document source metadata.
     */
    async documentsFilesSourceMetadataRead(requestParameters: DocumentsFilesSourceMetadataReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentFileSourceMetadata> {
        const response = await this.documentsFilesSourceMetadataReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async documentsFilesUpdateRaw(requestParameters: DocumentsFilesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentFile>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsFilesUpdate().'
            );
        }

        if (requestParameters['documentFileId'] == null) {
            throw new runtime.RequiredError(
                'documentFileId',
                'Required parameter "documentFileId" was null or undefined when calling documentsFilesUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsFilesUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/files/{document_file_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_file_id"}}`, encodeURIComponent(String(requestParameters['documentFileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentFileToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFileFromJSON(jsonValue));
    }

    /**
     */
    async documentsFilesUpdate(requestParameters: DocumentsFilesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentFile> {
        const response = await this.documentsFilesUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all the indexes instance nodes where this document is found.
     */
    async documentsIndexesListRaw(requestParameters: DocumentsIndexesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsIndexesList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsIndexesList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/indexes/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsIndexesList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the indexes instance nodes where this document is found.
     */
    async documentsIndexesList(requestParameters: DocumentsIndexesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsIndexesList200Response> {
        const response = await this.documentsIndexesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all the documents.
     */
    async documentsListRaw(requestParameters: DocumentsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CabinetsDocumentsList200Response>> {
        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CabinetsDocumentsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the documents.
     */
    async documentsList(requestParameters: DocumentsListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CabinetsDocumentsList200Response> {
        const response = await this.documentsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add an existing metadata type and value to the selected document.
     */
    async documentsMetadataCreateRaw(requestParameters: DocumentsMetadataCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentMetadata>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsMetadataCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsMetadataCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/metadata/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentMetadataToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentMetadataFromJSON(jsonValue));
    }

    /**
     * Add an existing metadata type and value to the selected document.
     */
    async documentsMetadataCreate(requestParameters: DocumentsMetadataCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentMetadata> {
        const response = await this.documentsMetadataCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove this metadata entry from the selected document.
     */
    async documentsMetadataDeleteRaw(requestParameters: DocumentsMetadataDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsMetadataDelete().'
            );
        }

        if (requestParameters['metadataId'] == null) {
            throw new runtime.RequiredError(
                'metadataId',
                'Required parameter "metadataId" was null or undefined when calling documentsMetadataDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/metadata/{metadata_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"metadata_id"}}`, encodeURIComponent(String(requestParameters['metadataId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove this metadata entry from the selected document.
     */
    async documentsMetadataDelete(requestParameters: DocumentsMetadataDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsMetadataDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a list of selected document\'s metadata types and values.
     */
    async documentsMetadataListRaw(requestParameters: DocumentsMetadataListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsMetadataList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsMetadataList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/metadata/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsMetadataList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of selected document\'s metadata types and values.
     */
    async documentsMetadataList(requestParameters: DocumentsMetadataListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsMetadataList200Response> {
        const response = await this.documentsMetadataListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the selected document metadata type and value.
     */
    async documentsMetadataPartialUpdateRaw(requestParameters: DocumentsMetadataPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentMetadata>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsMetadataPartialUpdate().'
            );
        }

        if (requestParameters['metadataId'] == null) {
            throw new runtime.RequiredError(
                'metadataId',
                'Required parameter "metadataId" was null or undefined when calling documentsMetadataPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsMetadataPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/metadata/{metadata_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"metadata_id"}}`, encodeURIComponent(String(requestParameters['metadataId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentMetadataToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentMetadataFromJSON(jsonValue));
    }

    /**
     * Edit the selected document metadata type and value.
     */
    async documentsMetadataPartialUpdate(requestParameters: DocumentsMetadataPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentMetadata> {
        const response = await this.documentsMetadataPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the selected document metadata type and value.
     */
    async documentsMetadataReadRaw(requestParameters: DocumentsMetadataReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentMetadata>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsMetadataRead().'
            );
        }

        if (requestParameters['metadataId'] == null) {
            throw new runtime.RequiredError(
                'metadataId',
                'Required parameter "metadataId" was null or undefined when calling documentsMetadataRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/metadata/{metadata_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"metadata_id"}}`, encodeURIComponent(String(requestParameters['metadataId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentMetadataFromJSON(jsonValue));
    }

    /**
     * Return the details of the selected document metadata type and value.
     */
    async documentsMetadataRead(requestParameters: DocumentsMetadataReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentMetadata> {
        const response = await this.documentsMetadataReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the selected document metadata type and value.
     */
    async documentsMetadataUpdateRaw(requestParameters: DocumentsMetadataUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentMetadata>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsMetadataUpdate().'
            );
        }

        if (requestParameters['metadataId'] == null) {
            throw new runtime.RequiredError(
                'metadataId',
                'Required parameter "metadataId" was null or undefined when calling documentsMetadataUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsMetadataUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/metadata/{metadata_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"metadata_id"}}`, encodeURIComponent(String(requestParameters['metadataId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentMetadataToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentMetadataFromJSON(jsonValue));
    }

    /**
     * Edit the selected document metadata type and value.
     */
    async documentsMetadataUpdate(requestParameters: DocumentsMetadataUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentMetadata> {
        const response = await this.documentsMetadataUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Submit a document for OCR.
     */
    async documentsOcrSubmitCreateRaw(requestParameters: DocumentsOcrSubmitCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsOcrSubmitCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/ocr/submit/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Submit a document for OCR.
     */
    async documentsOcrSubmitCreate(requestParameters: DocumentsOcrSubmitCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsOcrSubmitCreateRaw(requestParameters, initOverrides);
    }

    /**
     * Edit the properties of the selected document.
     */
    async documentsPartialUpdateRaw(requestParameters: DocumentsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Edit the properties of the selected document.
     */
    async documentsPartialUpdate(requestParameters: DocumentsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.documentsPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the selected document.
     */
    async documentsReadRaw(requestParameters: DocumentsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Return the details of the selected document.
     */
    async documentsRead(requestParameters: DocumentsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.documentsReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of the smart link documents that apply to the document.
     */
    async documentsResolvedSmartLinksDocumentsListRaw(requestParameters: DocumentsResolvedSmartLinksDocumentsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsResolvedSmartLinksDocumentsList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsResolvedSmartLinksDocumentsList().'
            );
        }

        if (requestParameters['resolvedSmartLinkId'] == null) {
            throw new runtime.RequiredError(
                'resolvedSmartLinkId',
                'Required parameter "resolvedSmartLinkId" was null or undefined when calling documentsResolvedSmartLinksDocumentsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/resolved_smart_links/{resolved_smart_link_id}/documents/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"resolved_smart_link_id"}}`, encodeURIComponent(String(requestParameters['resolvedSmartLinkId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsResolvedSmartLinksDocumentsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of the smart link documents that apply to the document.
     */
    async documentsResolvedSmartLinksDocumentsList(requestParameters: DocumentsResolvedSmartLinksDocumentsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsResolvedSmartLinksDocumentsList200Response> {
        const response = await this.documentsResolvedSmartLinksDocumentsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of the smart links that apply to the document.
     */
    async documentsResolvedSmartLinksListRaw(requestParameters: DocumentsResolvedSmartLinksListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsResolvedSmartLinksList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsResolvedSmartLinksList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/resolved_smart_links/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsResolvedSmartLinksList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of the smart links that apply to the document.
     */
    async documentsResolvedSmartLinksList(requestParameters: DocumentsResolvedSmartLinksListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsResolvedSmartLinksList200Response> {
        const response = await this.documentsResolvedSmartLinksListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the selected resolved smart link.
     */
    async documentsResolvedSmartLinksReadRaw(requestParameters: DocumentsResolvedSmartLinksReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResolvedSmartLink>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsResolvedSmartLinksRead().'
            );
        }

        if (requestParameters['resolvedSmartLinkId'] == null) {
            throw new runtime.RequiredError(
                'resolvedSmartLinkId',
                'Required parameter "resolvedSmartLinkId" was null or undefined when calling documentsResolvedSmartLinksRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/resolved_smart_links/{resolved_smart_link_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"resolved_smart_link_id"}}`, encodeURIComponent(String(requestParameters['resolvedSmartLinkId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResolvedSmartLinkFromJSON(jsonValue));
    }

    /**
     * Return the details of the selected resolved smart link.
     */
    async documentsResolvedSmartLinksRead(requestParameters: DocumentsResolvedSmartLinksReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResolvedSmartLink> {
        const response = await this.documentsResolvedSmartLinksReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of resolved web links for the specified document.
     */
    async documentsResolvedWebLinksListRaw(requestParameters: DocumentsResolvedWebLinksListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsResolvedWebLinksList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsResolvedWebLinksList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/resolved_web_links/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsResolvedWebLinksList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of resolved web links for the specified document.
     */
    async documentsResolvedWebLinksList(requestParameters: DocumentsResolvedWebLinksListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsResolvedWebLinksList200Response> {
        const response = await this.documentsResolvedWebLinksListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Perform a redirection to the target URL of the selected resolved smart link.
     */
    async documentsResolvedWebLinksNavigateReadRaw(requestParameters: DocumentsResolvedWebLinksNavigateReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsResolvedWebLinksNavigateRead().'
            );
        }

        if (requestParameters['resolvedWebLinkId'] == null) {
            throw new runtime.RequiredError(
                'resolvedWebLinkId',
                'Required parameter "resolvedWebLinkId" was null or undefined when calling documentsResolvedWebLinksNavigateRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/resolved_web_links/{resolved_web_link_id}/navigate/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"resolved_web_link_id"}}`, encodeURIComponent(String(requestParameters['resolvedWebLinkId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Perform a redirection to the target URL of the selected resolved smart link.
     */
    async documentsResolvedWebLinksNavigateRead(requestParameters: DocumentsResolvedWebLinksNavigateReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.documentsResolvedWebLinksNavigateReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the selected resolved smart link.
     */
    async documentsResolvedWebLinksReadRaw(requestParameters: DocumentsResolvedWebLinksReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResolvedWebLink>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsResolvedWebLinksRead().'
            );
        }

        if (requestParameters['resolvedWebLinkId'] == null) {
            throw new runtime.RequiredError(
                'resolvedWebLinkId',
                'Required parameter "resolvedWebLinkId" was null or undefined when calling documentsResolvedWebLinksRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/resolved_web_links/{resolved_web_link_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"resolved_web_link_id"}}`, encodeURIComponent(String(requestParameters['resolvedWebLinkId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResolvedWebLinkFromJSON(jsonValue));
    }

    /**
     * Return the details of the selected resolved smart link.
     */
    async documentsResolvedWebLinksRead(requestParameters: DocumentsResolvedWebLinksReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResolvedWebLink> {
        const response = await this.documentsResolvedWebLinksReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new signature_capture.
     */
    async documentsSignatureCapturesCreateRaw(requestParameters: DocumentsSignatureCapturesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SignatureCapture>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsSignatureCapturesCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsSignatureCapturesCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/signature_captures/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SignatureCaptureToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SignatureCaptureFromJSON(jsonValue));
    }

    /**
     * Create a new signature_capture.
     */
    async documentsSignatureCapturesCreate(requestParameters: DocumentsSignatureCapturesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SignatureCapture> {
        const response = await this.documentsSignatureCapturesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the selected signature_capture.
     */
    async documentsSignatureCapturesDeleteRaw(requestParameters: DocumentsSignatureCapturesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsSignatureCapturesDelete().'
            );
        }

        if (requestParameters['signatureCaptureId'] == null) {
            throw new runtime.RequiredError(
                'signatureCaptureId',
                'Required parameter "signatureCaptureId" was null or undefined when calling documentsSignatureCapturesDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/signature_captures/{signature_capture_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"signature_capture_id"}}`, encodeURIComponent(String(requestParameters['signatureCaptureId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the selected signature_capture.
     */
    async documentsSignatureCapturesDelete(requestParameters: DocumentsSignatureCapturesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsSignatureCapturesDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Returns an image representation of the selected signature capture.
     */
    async documentsSignatureCapturesImageReadRaw(requestParameters: DocumentsSignatureCapturesImageReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsSignatureCapturesImageRead().'
            );
        }

        if (requestParameters['signatureCaptureId'] == null) {
            throw new runtime.RequiredError(
                'signatureCaptureId',
                'Required parameter "signatureCaptureId" was null or undefined when calling documentsSignatureCapturesImageRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/signature_captures/{signature_capture_id}/image/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"signature_capture_id"}}`, encodeURIComponent(String(requestParameters['signatureCaptureId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns an image representation of the selected signature capture.
     */
    async documentsSignatureCapturesImageRead(requestParameters: DocumentsSignatureCapturesImageReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsSignatureCapturesImageReadRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a list of all the signature_captures.
     */
    async documentsSignatureCapturesListRaw(requestParameters: DocumentsSignatureCapturesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsSignatureCapturesList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsSignatureCapturesList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/signature_captures/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsSignatureCapturesList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the signature_captures.
     */
    async documentsSignatureCapturesList(requestParameters: DocumentsSignatureCapturesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsSignatureCapturesList200Response> {
        const response = await this.documentsSignatureCapturesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the selected signature_capture.
     */
    async documentsSignatureCapturesPartialUpdateRaw(requestParameters: DocumentsSignatureCapturesPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SignatureCapture>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsSignatureCapturesPartialUpdate().'
            );
        }

        if (requestParameters['signatureCaptureId'] == null) {
            throw new runtime.RequiredError(
                'signatureCaptureId',
                'Required parameter "signatureCaptureId" was null or undefined when calling documentsSignatureCapturesPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsSignatureCapturesPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/signature_captures/{signature_capture_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"signature_capture_id"}}`, encodeURIComponent(String(requestParameters['signatureCaptureId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SignatureCaptureToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SignatureCaptureFromJSON(jsonValue));
    }

    /**
     * Edit the selected signature_capture.
     */
    async documentsSignatureCapturesPartialUpdate(requestParameters: DocumentsSignatureCapturesPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SignatureCapture> {
        const response = await this.documentsSignatureCapturesPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the selected signature_capture.
     */
    async documentsSignatureCapturesReadRaw(requestParameters: DocumentsSignatureCapturesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SignatureCapture>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsSignatureCapturesRead().'
            );
        }

        if (requestParameters['signatureCaptureId'] == null) {
            throw new runtime.RequiredError(
                'signatureCaptureId',
                'Required parameter "signatureCaptureId" was null or undefined when calling documentsSignatureCapturesRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/signature_captures/{signature_capture_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"signature_capture_id"}}`, encodeURIComponent(String(requestParameters['signatureCaptureId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SignatureCaptureFromJSON(jsonValue));
    }

    /**
     * Return the details of the selected signature_capture.
     */
    async documentsSignatureCapturesRead(requestParameters: DocumentsSignatureCapturesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SignatureCapture> {
        const response = await this.documentsSignatureCapturesReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the selected signature_capture.
     */
    async documentsSignatureCapturesUpdateRaw(requestParameters: DocumentsSignatureCapturesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SignatureCapture>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsSignatureCapturesUpdate().'
            );
        }

        if (requestParameters['signatureCaptureId'] == null) {
            throw new runtime.RequiredError(
                'signatureCaptureId',
                'Required parameter "signatureCaptureId" was null or undefined when calling documentsSignatureCapturesUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsSignatureCapturesUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/signature_captures/{signature_capture_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"signature_capture_id"}}`, encodeURIComponent(String(requestParameters['signatureCaptureId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SignatureCaptureToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SignatureCaptureFromJSON(jsonValue));
    }

    /**
     * Edit the selected signature_capture.
     */
    async documentsSignatureCapturesUpdate(requestParameters: DocumentsSignatureCapturesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SignatureCapture> {
        const response = await this.documentsSignatureCapturesUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Attach a tag to a document.
     */
    async documentsTagsAttachCreateRaw(requestParameters: DocumentsTagsAttachCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTagAttach>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsTagsAttachCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsTagsAttachCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/tags/attach/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTagAttachToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTagAttachFromJSON(jsonValue));
    }

    /**
     * Attach a tag to a document.
     */
    async documentsTagsAttachCreate(requestParameters: DocumentsTagsAttachCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTagAttach> {
        const response = await this.documentsTagsAttachCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all the tags attached to a document.
     */
    async documentsTagsListRaw(requestParameters: DocumentsTagsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsTagsList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsTagsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/tags/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsTagsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the tags attached to a document.
     */
    async documentsTagsList(requestParameters: DocumentsTagsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsTagsList200Response> {
        const response = await this.documentsTagsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove a tag from a document.
     */
    async documentsTagsRemoveCreateRaw(requestParameters: DocumentsTagsRemoveCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentTagRemove>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsTagsRemoveCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsTagsRemoveCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/tags/remove/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentTagRemoveToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentTagRemoveFromJSON(jsonValue));
    }

    /**
     * Remove a tag from a document.
     */
    async documentsTagsRemoveCreate(requestParameters: DocumentsTagsRemoveCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentTagRemove> {
        const response = await this.documentsTagsRemoveCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Change the type of the selected document.
     */
    async documentsTypeChangeCreateRaw(requestParameters: DocumentsTypeChangeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentChangeType>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsTypeChangeCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsTypeChangeCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/type/change/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentChangeTypeToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentChangeTypeFromJSON(jsonValue));
    }

    /**
     * Change the type of the selected document.
     */
    async documentsTypeChangeCreate(requestParameters: DocumentsTypeChangeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentChangeType> {
        const response = await this.documentsTypeChangeCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the properties of the selected document.
     */
    async documentsUpdateRaw(requestParameters: DocumentsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Document>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentFromJSON(jsonValue));
    }

    /**
     * Edit the properties of the selected document.
     */
    async documentsUpdate(requestParameters: DocumentsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Document> {
        const response = await this.documentsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new document and a new document file.
     */
    async documentsUploadCreateRaw(requestParameters: DocumentsUploadCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentUpload>> {
        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsUploadCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/upload/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentUploadToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentUploadFromJSON(jsonValue));
    }

    /**
     * Create a new document and a new document file.
     */
    async documentsUploadCreate(requestParameters: DocumentsUploadCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentUpload> {
        const response = await this.documentsUploadCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new document version.
     */
    async documentsVersionsCreateRaw(requestParameters: DocumentsVersionsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersion>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsVersionsCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentVersionToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionFromJSON(jsonValue));
    }

    /**
     * Create a new document version.
     */
    async documentsVersionsCreate(requestParameters: DocumentsVersionsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersion> {
        const response = await this.documentsVersionsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the selected document version.
     */
    async documentsVersionsDeleteRaw(requestParameters: DocumentsVersionsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsDelete().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the selected document version.
     */
    async documentsVersionsDelete(requestParameters: DocumentsVersionsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsVersionsDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Exports the specified document version.
     */
    async documentsVersionsExportCreateRaw(requestParameters: DocumentsVersionsExportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsExportCreate().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsExportCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsVersionsExportCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/export/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['data'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Exports the specified document version.
     */
    async documentsVersionsExportCreate(requestParameters: DocumentsVersionsExportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.documentsVersionsExportCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return a list of the selected document\'s versions.
     */
    async documentsVersionsListRaw(requestParameters: DocumentsVersionsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsVersionsList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsVersionsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Return a list of the selected document\'s versions.
     */
    async documentsVersionsList(requestParameters: DocumentsVersionsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsVersionsList200Response> {
        const response = await this.documentsVersionsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Execute a modification backend on the selected document version.
     */
    async documentsVersionsModifyCreateRaw(requestParameters: DocumentsVersionsModifyCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersionModificationExecute>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsModifyCreate().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsModifyCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsVersionsModifyCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/modify/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentVersionModificationExecuteToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionModificationExecuteFromJSON(jsonValue));
    }

    /**
     * Execute a modification backend on the selected document version.
     */
    async documentsVersionsModifyCreate(requestParameters: DocumentsVersionsModifyCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersionModificationExecute> {
        const response = await this.documentsVersionsModifyCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Submit a document version for OCR.
     */
    async documentsVersionsOcrSubmitCreateRaw(requestParameters: DocumentsVersionsOcrSubmitCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsOcrSubmitCreate().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsOcrSubmitCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/ocr/submit/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Submit a document version for OCR.
     */
    async documentsVersionsOcrSubmitCreate(requestParameters: DocumentsVersionsOcrSubmitCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsVersionsOcrSubmitCreateRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new document version page.
     */
    async documentsVersionsPagesCreateRaw(requestParameters: DocumentsVersionsPagesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersionPage>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsPagesCreate().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsPagesCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsVersionsPagesCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/pages/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentVersionPageToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionPageFromJSON(jsonValue));
    }

    /**
     * Create a new document version page.
     */
    async documentsVersionsPagesCreate(requestParameters: DocumentsVersionsPagesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersionPage> {
        const response = await this.documentsVersionsPagesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the selected document version page.
     */
    async documentsVersionsPagesDeleteRaw(requestParameters: DocumentsVersionsPagesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsPagesDelete().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsPagesDelete().'
            );
        }

        if (requestParameters['documentVersionPageId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionPageId',
                'Required parameter "documentVersionPageId" was null or undefined when calling documentsVersionsPagesDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));
        urlPath = urlPath.replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(requestParameters['documentVersionPageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the selected document version page.
     */
    async documentsVersionsPagesDelete(requestParameters: DocumentsVersionsPagesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsVersionsPagesDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Returns an image representation of the selected document version page.
     */
    async documentsVersionsPagesImageReadRaw(requestParameters: DocumentsVersionsPagesImageReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsPagesImageRead().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsPagesImageRead().'
            );
        }

        if (requestParameters['documentVersionPageId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionPageId',
                'Required parameter "documentVersionPageId" was null or undefined when calling documentsVersionsPagesImageRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/image/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));
        urlPath = urlPath.replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(requestParameters['documentVersionPageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns an image representation of the selected document version page.
     */
    async documentsVersionsPagesImageRead(requestParameters: DocumentsVersionsPagesImageReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.documentsVersionsPagesImageReadRaw(requestParameters, initOverrides);
    }

    /**
     * Returns an list of the pages for the selected document version.
     */
    async documentsVersionsPagesListRaw(requestParameters: DocumentsVersionsPagesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsVersionsPagesList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsPagesList().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsPagesList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/pages/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsVersionsPagesList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns an list of the pages for the selected document version.
     */
    async documentsVersionsPagesList(requestParameters: DocumentsVersionsPagesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsVersionsPagesList200Response> {
        const response = await this.documentsVersionsPagesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the OCR content of the selected document page.
     */
    async documentsVersionsPagesOcrPartialUpdateRaw(requestParameters: DocumentsVersionsPagesOcrPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersionPageOCRContent>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsPagesOcrPartialUpdate().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsPagesOcrPartialUpdate().'
            );
        }

        if (requestParameters['documentVersionPageId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionPageId',
                'Required parameter "documentVersionPageId" was null or undefined when calling documentsVersionsPagesOcrPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsVersionsPagesOcrPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/ocr/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));
        urlPath = urlPath.replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(requestParameters['documentVersionPageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentVersionPageOCRContentToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionPageOCRContentFromJSON(jsonValue));
    }

    /**
     * Edit the OCR content of the selected document page.
     */
    async documentsVersionsPagesOcrPartialUpdate(requestParameters: DocumentsVersionsPagesOcrPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersionPageOCRContent> {
        const response = await this.documentsVersionsPagesOcrPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the OCR content of the selected document page.
     */
    async documentsVersionsPagesOcrReadRaw(requestParameters: DocumentsVersionsPagesOcrReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersionPageOCRContent>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsPagesOcrRead().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsPagesOcrRead().'
            );
        }

        if (requestParameters['documentVersionPageId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionPageId',
                'Required parameter "documentVersionPageId" was null or undefined when calling documentsVersionsPagesOcrRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/ocr/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));
        urlPath = urlPath.replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(requestParameters['documentVersionPageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionPageOCRContentFromJSON(jsonValue));
    }

    /**
     * Returns the OCR content of the selected document page.
     */
    async documentsVersionsPagesOcrRead(requestParameters: DocumentsVersionsPagesOcrReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersionPageOCRContent> {
        const response = await this.documentsVersionsPagesOcrReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the OCR content of the selected document page.
     */
    async documentsVersionsPagesOcrUpdateRaw(requestParameters: DocumentsVersionsPagesOcrUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersionPageOCRContent>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsPagesOcrUpdate().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsPagesOcrUpdate().'
            );
        }

        if (requestParameters['documentVersionPageId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionPageId',
                'Required parameter "documentVersionPageId" was null or undefined when calling documentsVersionsPagesOcrUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsVersionsPagesOcrUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/ocr/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));
        urlPath = urlPath.replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(requestParameters['documentVersionPageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentVersionPageOCRContentToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionPageOCRContentFromJSON(jsonValue));
    }

    /**
     * Edit the OCR content of the selected document page.
     */
    async documentsVersionsPagesOcrUpdate(requestParameters: DocumentsVersionsPagesOcrUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersionPageOCRContent> {
        const response = await this.documentsVersionsPagesOcrUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the properties of the selected document version page.
     */
    async documentsVersionsPagesPartialUpdateRaw(requestParameters: DocumentsVersionsPagesPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersionPage>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsPagesPartialUpdate().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsPagesPartialUpdate().'
            );
        }

        if (requestParameters['documentVersionPageId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionPageId',
                'Required parameter "documentVersionPageId" was null or undefined when calling documentsVersionsPagesPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsVersionsPagesPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));
        urlPath = urlPath.replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(requestParameters['documentVersionPageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentVersionPageToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionPageFromJSON(jsonValue));
    }

    /**
     * Edit the properties of the selected document version page.
     */
    async documentsVersionsPagesPartialUpdate(requestParameters: DocumentsVersionsPagesPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersionPage> {
        const response = await this.documentsVersionsPagesPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the selected document version page details.
     */
    async documentsVersionsPagesReadRaw(requestParameters: DocumentsVersionsPagesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersionPage>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsPagesRead().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsPagesRead().'
            );
        }

        if (requestParameters['documentVersionPageId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionPageId',
                'Required parameter "documentVersionPageId" was null or undefined when calling documentsVersionsPagesRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));
        urlPath = urlPath.replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(requestParameters['documentVersionPageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionPageFromJSON(jsonValue));
    }

    /**
     * Returns the selected document version page details.
     */
    async documentsVersionsPagesRead(requestParameters: DocumentsVersionsPagesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersionPage> {
        const response = await this.documentsVersionsPagesReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the properties of the selected document version page.
     */
    async documentsVersionsPagesUpdateRaw(requestParameters: DocumentsVersionsPagesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersionPage>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsPagesUpdate().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsPagesUpdate().'
            );
        }

        if (requestParameters['documentVersionPageId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionPageId',
                'Required parameter "documentVersionPageId" was null or undefined when calling documentsVersionsPagesUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsVersionsPagesUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));
        urlPath = urlPath.replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(requestParameters['documentVersionPageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentVersionPageToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionPageFromJSON(jsonValue));
    }

    /**
     * Edit the properties of the selected document version page.
     */
    async documentsVersionsPagesUpdate(requestParameters: DocumentsVersionsPagesUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersionPage> {
        const response = await this.documentsVersionsPagesUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the properties of the selected document version.
     */
    async documentsVersionsPartialUpdateRaw(requestParameters: DocumentsVersionsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersion>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsPartialUpdate().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsPartialUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsVersionsPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentVersionToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionFromJSON(jsonValue));
    }

    /**
     * Edit the properties of the selected document version.
     */
    async documentsVersionsPartialUpdate(requestParameters: DocumentsVersionsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersion> {
        const response = await this.documentsVersionsPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the selected document version details.
     */
    async documentsVersionsReadRaw(requestParameters: DocumentsVersionsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersion>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsRead().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionFromJSON(jsonValue));
    }

    /**
     * Returns the selected document version details.
     */
    async documentsVersionsRead(requestParameters: DocumentsVersionsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersion> {
        const response = await this.documentsVersionsReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit the properties of the selected document version.
     */
    async documentsVersionsUpdateRaw(requestParameters: DocumentsVersionsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentVersion>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsVersionsUpdate().'
            );
        }

        if (requestParameters['documentVersionId'] == null) {
            throw new runtime.RequiredError(
                'documentVersionId',
                'Required parameter "documentVersionId" was null or undefined when calling documentsVersionsUpdate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsVersionsUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/versions/{document_version_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"document_version_id"}}`, encodeURIComponent(String(requestParameters['documentVersionId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentVersionToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentVersionFromJSON(jsonValue));
    }

    /**
     * Edit the properties of the selected document version.
     */
    async documentsVersionsUpdate(requestParameters: DocumentsVersionsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentVersion> {
        const response = await this.documentsVersionsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Launch a new workflow instance for the specified document.
     */
    async documentsWorkflowInstancesLaunchCreateRaw(requestParameters: DocumentsWorkflowInstancesLaunchCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowInstanceLaunch>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsWorkflowInstancesLaunchCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsWorkflowInstancesLaunchCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/workflow_instances/launch/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkflowInstanceLaunchToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkflowInstanceLaunchFromJSON(jsonValue));
    }

    /**
     * Launch a new workflow instance for the specified document.
     */
    async documentsWorkflowInstancesLaunchCreate(requestParameters: DocumentsWorkflowInstancesLaunchCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowInstanceLaunch> {
        const response = await this.documentsWorkflowInstancesLaunchCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all the document workflow instances.
     */
    async documentsWorkflowInstancesListRaw(requestParameters: DocumentsWorkflowInstancesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsWorkflowInstancesList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsWorkflowInstancesList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/workflow_instances/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsWorkflowInstancesList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the document workflow instances.
     */
    async documentsWorkflowInstancesList(requestParameters: DocumentsWorkflowInstancesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsWorkflowInstancesList200Response> {
        const response = await this.documentsWorkflowInstancesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Transition a document workflow by creating a new document workflow instance log entry.
     */
    async documentsWorkflowInstancesLogEntriesCreateRaw(requestParameters: DocumentsWorkflowInstancesLogEntriesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowInstanceLogEntry>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsWorkflowInstancesLogEntriesCreate().'
            );
        }

        if (requestParameters['workflowInstanceId'] == null) {
            throw new runtime.RequiredError(
                'workflowInstanceId',
                'Required parameter "workflowInstanceId" was null or undefined when calling documentsWorkflowInstancesLogEntriesCreate().'
            );
        }

        if (requestParameters['data'] == null) {
            throw new runtime.RequiredError(
                'data',
                'Required parameter "data" was null or undefined when calling documentsWorkflowInstancesLogEntriesCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/workflow_instances/{workflow_instance_id}/log_entries/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"workflow_instance_id"}}`, encodeURIComponent(String(requestParameters['workflowInstanceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkflowInstanceLogEntryToJSON(requestParameters['data']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkflowInstanceLogEntryFromJSON(jsonValue));
    }

    /**
     * Transition a document workflow by creating a new document workflow instance log entry.
     */
    async documentsWorkflowInstancesLogEntriesCreate(requestParameters: DocumentsWorkflowInstancesLogEntriesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowInstanceLogEntry> {
        const response = await this.documentsWorkflowInstancesLogEntriesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all the document workflow instances log entries.
     */
    async documentsWorkflowInstancesLogEntriesListRaw(requestParameters: DocumentsWorkflowInstancesLogEntriesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsWorkflowInstancesLogEntriesList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsWorkflowInstancesLogEntriesList().'
            );
        }

        if (requestParameters['workflowInstanceId'] == null) {
            throw new runtime.RequiredError(
                'workflowInstanceId',
                'Required parameter "workflowInstanceId" was null or undefined when calling documentsWorkflowInstancesLogEntriesList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/workflow_instances/{workflow_instance_id}/log_entries/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"workflow_instance_id"}}`, encodeURIComponent(String(requestParameters['workflowInstanceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsWorkflowInstancesLogEntriesList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the document workflow instances log entries.
     */
    async documentsWorkflowInstancesLogEntriesList(requestParameters: DocumentsWorkflowInstancesLogEntriesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsWorkflowInstancesLogEntriesList200Response> {
        const response = await this.documentsWorkflowInstancesLogEntriesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the selected document instances log entry.
     */
    async documentsWorkflowInstancesLogEntriesReadRaw(requestParameters: DocumentsWorkflowInstancesLogEntriesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowInstanceLogEntry>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsWorkflowInstancesLogEntriesRead().'
            );
        }

        if (requestParameters['workflowInstanceId'] == null) {
            throw new runtime.RequiredError(
                'workflowInstanceId',
                'Required parameter "workflowInstanceId" was null or undefined when calling documentsWorkflowInstancesLogEntriesRead().'
            );
        }

        if (requestParameters['workflowInstanceLogEntryId'] == null) {
            throw new runtime.RequiredError(
                'workflowInstanceLogEntryId',
                'Required parameter "workflowInstanceLogEntryId" was null or undefined when calling documentsWorkflowInstancesLogEntriesRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/workflow_instances/{workflow_instance_id}/log_entries/{workflow_instance_log_entry_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"workflow_instance_id"}}`, encodeURIComponent(String(requestParameters['workflowInstanceId'])));
        urlPath = urlPath.replace(`{${"workflow_instance_log_entry_id"}}`, encodeURIComponent(String(requestParameters['workflowInstanceLogEntryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkflowInstanceLogEntryFromJSON(jsonValue));
    }

    /**
     * Return the details of the selected document instances log entry.
     */
    async documentsWorkflowInstancesLogEntriesRead(requestParameters: DocumentsWorkflowInstancesLogEntriesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowInstanceLogEntry> {
        const response = await this.documentsWorkflowInstancesLogEntriesReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all the possible transition choices for the workflow instance.
     */
    async documentsWorkflowInstancesLogEntriesTransitionsListRaw(requestParameters: DocumentsWorkflowInstancesLogEntriesTransitionsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentsWorkflowInstancesLogEntriesTransitionsList200Response>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsWorkflowInstancesLogEntriesTransitionsList().'
            );
        }

        if (requestParameters['workflowInstanceId'] == null) {
            throw new runtime.RequiredError(
                'workflowInstanceId',
                'Required parameter "workflowInstanceId" was null or undefined when calling documentsWorkflowInstancesLogEntriesTransitionsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['ordering'] != null) {
            queryParameters['_ordering'] = requestParameters['ordering'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/workflow_instances/{workflow_instance_id}/log_entries/transitions/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"workflow_instance_id"}}`, encodeURIComponent(String(requestParameters['workflowInstanceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentsWorkflowInstancesLogEntriesTransitionsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all the possible transition choices for the workflow instance.
     */
    async documentsWorkflowInstancesLogEntriesTransitionsList(requestParameters: DocumentsWorkflowInstancesLogEntriesTransitionsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentsWorkflowInstancesLogEntriesTransitionsList200Response> {
        const response = await this.documentsWorkflowInstancesLogEntriesTransitionsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return the details of the selected document workflow instances.
     */
    async documentsWorkflowInstancesReadRaw(requestParameters: DocumentsWorkflowInstancesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkflowInstance>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling documentsWorkflowInstancesRead().'
            );
        }

        if (requestParameters['workflowInstanceId'] == null) {
            throw new runtime.RequiredError(
                'workflowInstanceId',
                'Required parameter "workflowInstanceId" was null or undefined when calling documentsWorkflowInstancesRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }

        let urlPath = `/documents/{document_id}/workflow_instances/{workflow_instance_id}/`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));
        urlPath = urlPath.replace(`{${"workflow_instance_id"}}`, encodeURIComponent(String(requestParameters['workflowInstanceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkflowInstanceFromJSON(jsonValue));
    }

    /**
     * Return the details of the selected document workflow instances.
     */
    async documentsWorkflowInstancesRead(requestParameters: DocumentsWorkflowInstancesReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkflowInstance> {
        const response = await this.documentsWorkflowInstancesReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
