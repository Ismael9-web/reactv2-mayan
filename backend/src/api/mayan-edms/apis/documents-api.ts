/* tslint:disable */
/* eslint-disable */
/**
 * Mayan EDMS API
 * Free Open Source Electronic Document Management System
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CabinetsDocumentsList200Response } from '../models';
// @ts-ignore
import type { CabinetsList200Response } from '../models';
// @ts-ignore
import type { Comment } from '../models';
// @ts-ignore
import type { DetachedSignature } from '../models';
// @ts-ignore
import type { DetachedSignatureUpload } from '../models';
// @ts-ignore
import type { Document } from '../models';
// @ts-ignore
import type { DocumentChangeType } from '../models';
// @ts-ignore
import type { DocumentCheckout } from '../models';
// @ts-ignore
import type { DocumentFile } from '../models';
// @ts-ignore
import type { DocumentFileMetadataDriverEntry } from '../models';
// @ts-ignore
import type { DocumentFileMetadataEntry } from '../models';
// @ts-ignore
import type { DocumentFilePage } from '../models';
// @ts-ignore
import type { DocumentFilePageContent } from '../models';
// @ts-ignore
import type { DocumentFileSourceMetadata } from '../models';
// @ts-ignore
import type { DocumentMetadata } from '../models';
// @ts-ignore
import type { DocumentTagAttach } from '../models';
// @ts-ignore
import type { DocumentTagRemove } from '../models';
// @ts-ignore
import type { DocumentUpload } from '../models';
// @ts-ignore
import type { DocumentVersion } from '../models';
// @ts-ignore
import type { DocumentVersionModificationExecute } from '../models';
// @ts-ignore
import type { DocumentVersionPage } from '../models';
// @ts-ignore
import type { DocumentVersionPageOCRContent } from '../models';
// @ts-ignore
import type { DocumentsAccessedList200Response } from '../models';
// @ts-ignore
import type { DocumentsCommentsList200Response } from '../models';
// @ts-ignore
import type { DocumentsDuplicatesList200Response } from '../models';
// @ts-ignore
import type { DocumentsFavoritesList200Response } from '../models';
// @ts-ignore
import type { DocumentsFilesFileMetadataDriversEntriesList200Response } from '../models';
// @ts-ignore
import type { DocumentsFilesFileMetadataDriversList200Response } from '../models';
// @ts-ignore
import type { DocumentsFilesList200Response } from '../models';
// @ts-ignore
import type { DocumentsFilesPagesList200Response } from '../models';
// @ts-ignore
import type { DocumentsFilesSignaturesDetachedList200Response } from '../models';
// @ts-ignore
import type { DocumentsFilesSignaturesEmbeddedList200Response } from '../models';
// @ts-ignore
import type { DocumentsFilesSourceMetadataList200Response } from '../models';
// @ts-ignore
import type { DocumentsIndexesList200Response } from '../models';
// @ts-ignore
import type { DocumentsMetadataList200Response } from '../models';
// @ts-ignore
import type { DocumentsResolvedSmartLinksDocumentsList200Response } from '../models';
// @ts-ignore
import type { DocumentsResolvedSmartLinksList200Response } from '../models';
// @ts-ignore
import type { DocumentsResolvedWebLinksList200Response } from '../models';
// @ts-ignore
import type { DocumentsSignatureCapturesList200Response } from '../models';
// @ts-ignore
import type { DocumentsTagsList200Response } from '../models';
// @ts-ignore
import type { DocumentsVersionsList200Response } from '../models';
// @ts-ignore
import type { DocumentsVersionsPagesList200Response } from '../models';
// @ts-ignore
import type { DocumentsWorkflowInstancesList200Response } from '../models';
// @ts-ignore
import type { DocumentsWorkflowInstancesLogEntriesList200Response } from '../models';
// @ts-ignore
import type { DocumentsWorkflowInstancesLogEntriesTransitionsList200Response } from '../models';
// @ts-ignore
import type { EmbeddedSignature } from '../models';
// @ts-ignore
import type { FavoriteDocument } from '../models';
// @ts-ignore
import type { ResolvedSmartLink } from '../models';
// @ts-ignore
import type { ResolvedWebLink } from '../models';
// @ts-ignore
import type { SignDetached } from '../models';
// @ts-ignore
import type { SignEmbedded } from '../models';
// @ts-ignore
import type { SignatureCapture } from '../models';
// @ts-ignore
import type { WorkflowInstance } from '../models';
// @ts-ignore
import type { WorkflowInstanceLaunch } from '../models';
// @ts-ignore
import type { WorkflowInstanceLogEntry } from '../models';
/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return a list of the recently accessed documents for the current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsAccessedList: async (ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents/accessed/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the cabinets to which a document belongs.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCabinetsList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsCabinetsList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/cabinets/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check in the selected document.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCheckoutDelete: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsCheckoutDelete', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/checkout/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the checkout details of the selected document entry.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCheckoutRead: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsCheckoutRead', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/checkout/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document comment.
         * @param {string} documentId 
         * @param {Comment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsCreate: async (documentId: string, data: Comment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsCommentsCreate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsCommentsCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/comments/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the selected document comment.
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsDelete: async (documentId: string, commentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsCommentsDelete', 'documentId', documentId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('documentsCommentsDelete', 'commentId', commentId)
            const localVarPath = `/documents/{document_id}/comments/{comment_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the document comments.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsCommentsList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/comments/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {Comment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsPartialUpdate: async (documentId: string, commentId: string, data: Comment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsCommentsPartialUpdate', 'documentId', documentId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('documentsCommentsPartialUpdate', 'commentId', commentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsCommentsPartialUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/comments/{comment_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of the selected document comment.
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsRead: async (documentId: string, commentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsCommentsRead', 'documentId', documentId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('documentsCommentsRead', 'commentId', commentId)
            const localVarPath = `/documents/{document_id}/comments/{comment_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {Comment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsUpdate: async (documentId: string, commentId: string, data: Comment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsCommentsUpdate', 'documentId', documentId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('documentsCommentsUpdate', 'commentId', commentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsCommentsUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/comments/{comment_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document.
         * @param {Document} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCreate: async (data: Document, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsCreate', 'data', data)
            const localVarPath = `/documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of the recently created documents.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCreatedList: async (ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents/created/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move the selected document to the thrash.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDelete: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsDelete', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of duplicated documents.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDuplicatedList: async (ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents/duplicated/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of the selected document\'s duplicates.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDuplicatesList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsDuplicatesList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/duplicates/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new document to the list of favorite documents for the current user.
         * @param {FavoriteDocument} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFavoritesCreate: async (data: FavoriteDocument, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsFavoritesCreate', 'data', data)
            const localVarPath = `/documents/favorites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the selected favorite document.
         * @param {string} favoriteDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFavoritesDelete: async (favoriteDocumentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'favoriteDocumentId' is not null or undefined
            assertParamExists('documentsFavoritesDelete', 'favoriteDocumentId', favoriteDocumentId)
            const localVarPath = `/documents/favorites/{favorite_document_id}/`
                .replace(`{${"favorite_document_id"}}`, encodeURIComponent(String(favoriteDocumentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of the favorite documents for the current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFavoritesList: async (ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents/favorites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the details of the selected favorite document.
         * @param {string} favoriteDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFavoritesRead: async (favoriteDocumentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'favoriteDocumentId' is not null or undefined
            assertParamExists('documentsFavoritesRead', 'favoriteDocumentId', favoriteDocumentId)
            const localVarPath = `/documents/favorites/{favorite_document_id}/`
                .replace(`{${"favorite_document_id"}}`, encodeURIComponent(String(favoriteDocumentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document file.
         * @param {string} documentId 
         * @param {DocumentFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesCreate: async (documentId: string, data: DocumentFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesCreate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsFilesCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/files/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the selected document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesDelete: async (documentId: string, documentFileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesDelete', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesDelete', 'documentFileId', documentFileId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesDownloadRead: async (documentId: string, documentFileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesDownloadRead', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesDownloadRead', 'documentFileId', documentFileId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/download/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of file metadata entries for the selected driver.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} driverId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesFileMetadataDriversEntriesList: async (documentId: string, documentFileId: string, driverId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversEntriesList', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversEntriesList', 'documentFileId', documentFileId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversEntriesList', 'driverId', driverId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/file_metadata/drivers/{driver_id}/entries/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)))
                .replace(`{${"driver_id"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the detail of selected document file metadata entry.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} driverId 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesFileMetadataDriversEntriesRead: async (documentId: string, documentFileId: string, driverId: string, entryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversEntriesRead', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversEntriesRead', 'documentFileId', documentFileId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversEntriesRead', 'driverId', driverId)
            // verify required parameter 'entryId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversEntriesRead', 'entryId', entryId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/file_metadata/drivers/{driver_id}/entries/{entry_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)))
                .replace(`{${"driver_id"}}`, encodeURIComponent(String(driverId)))
                .replace(`{${"entry_id"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of selected document\'s file metadata drivers.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesFileMetadataDriversList: async (documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversList', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversList', 'documentFileId', documentFileId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/file_metadata/drivers/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of the document file metadata driver.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} driverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesFileMetadataDriversRead: async (documentId: string, documentFileId: string, driverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversRead', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversRead', 'documentFileId', documentFileId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataDriversRead', 'driverId', driverId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/file_metadata/drivers/{driver_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)))
                .replace(`{${"driver_id"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a document file for file metadata processing.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesFileMetadataSubmitCreate: async (documentId: string, documentFileId: string, data: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataSubmitCreate', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesFileMetadataSubmitCreate', 'documentFileId', documentFileId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsFilesFileMetadataSubmitCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/file_metadata/submit/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of the selected document\'s files.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/files/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFilePageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesPagesContentRead: async (documentId: string, documentFileId: string, documentFilePageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesPagesContentRead', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesPagesContentRead', 'documentFileId', documentFileId)
            // verify required parameter 'documentFilePageId' is not null or undefined
            assertParamExists('documentsFilesPagesContentRead', 'documentFilePageId', documentFilePageId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/pages/{document_file_page_id}/content/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)))
                .replace(`{${"document_file_page_id"}}`, encodeURIComponent(String(documentFilePageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an image representation of the selected document.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFilePageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesPagesImageRead: async (documentId: string, documentFileId: string, documentFilePageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesPagesImageRead', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesPagesImageRead', 'documentFileId', documentFileId)
            // verify required parameter 'documentFilePageId' is not null or undefined
            assertParamExists('documentsFilesPagesImageRead', 'documentFilePageId', documentFilePageId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/pages/{document_file_page_id}/image/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)))
                .replace(`{${"document_file_page_id"}}`, encodeURIComponent(String(documentFilePageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesPagesList: async (documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesPagesList', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesPagesList', 'documentFileId', documentFileId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/pages/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the selected document page details.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFilePageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesPagesRead: async (documentId: string, documentFileId: string, documentFilePageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesPagesRead', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesPagesRead', 'documentFileId', documentFileId)
            // verify required parameter 'documentFilePageId' is not null or undefined
            assertParamExists('documentsFilesPagesRead', 'documentFilePageId', documentFilePageId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/pages/{document_file_page_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)))
                .replace(`{${"document_file_page_id"}}`, encodeURIComponent(String(documentFilePageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {DocumentFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesPartialUpdate: async (documentId: string, documentFileId: string, data: DocumentFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesPartialUpdate', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesPartialUpdate', 'documentFileId', documentFileId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsFilesPartialUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the selected document file details.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesRead: async (documentId: string, documentFileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesRead', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesRead', 'documentFileId', documentFileId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an detached signature of the selected document.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} detachedSignatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesDetachedDelete: async (documentId: string, documentFileId: string, detachedSignatureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedDelete', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedDelete', 'documentFileId', documentFileId)
            // verify required parameter 'detachedSignatureId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedDelete', 'detachedSignatureId', detachedSignatureId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/signatures/detached/{detached_signature_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)))
                .replace(`{${"detached_signature_id"}}`, encodeURIComponent(String(detachedSignatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the detached signatures of a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesDetachedList: async (documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedList', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedList', 'documentFileId', documentFileId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/signatures/detached/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of the selected detached signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} detachedSignatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesDetachedRead: async (documentId: string, documentFileId: string, detachedSignatureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedRead', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedRead', 'documentFileId', documentFileId)
            // verify required parameter 'detachedSignatureId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedRead', 'detachedSignatureId', detachedSignatureId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/signatures/detached/{detached_signature_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)))
                .replace(`{${"detached_signature_id"}}`, encodeURIComponent(String(detachedSignatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign a document file with a detached signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {SignDetached} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesDetachedSignCreate: async (documentId: string, documentFileId: string, data: SignDetached, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedSignCreate', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedSignCreate', 'documentFileId', documentFileId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedSignCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/signatures/detached/sign/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a detached signature file for a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {DetachedSignatureUpload} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesDetachedUploadCreate: async (documentId: string, documentFileId: string, data: DetachedSignatureUpload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedUploadCreate', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedUploadCreate', 'documentFileId', documentFileId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsFilesSignaturesDetachedUploadCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/signatures/detached/upload/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the embedded signatures of a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesEmbeddedList: async (documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesSignaturesEmbeddedList', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesSignaturesEmbeddedList', 'documentFileId', documentFileId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/signatures/embedded/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the details of the selected embedded signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} embeddedSignatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesEmbeddedRead: async (documentId: string, documentFileId: string, embeddedSignatureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesSignaturesEmbeddedRead', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesSignaturesEmbeddedRead', 'documentFileId', documentFileId)
            // verify required parameter 'embeddedSignatureId' is not null or undefined
            assertParamExists('documentsFilesSignaturesEmbeddedRead', 'embeddedSignatureId', embeddedSignatureId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/signatures/embedded/{embedded_signature_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)))
                .replace(`{${"embedded_signature_id"}}`, encodeURIComponent(String(embeddedSignatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign a document file with an embedded signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {SignEmbedded} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesEmbeddedSignCreate: async (documentId: string, documentFileId: string, data: SignEmbedded, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesSignaturesEmbeddedSignCreate', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesSignaturesEmbeddedSignCreate', 'documentFileId', documentFileId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsFilesSignaturesEmbeddedSignCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/signatures/embedded/sign/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of selected document\'s source metadata values.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSourceMetadataList: async (documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesSourceMetadataList', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesSourceMetadataList', 'documentFileId', documentFileId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/source_metadata/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the details of the selected document source metadata.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFileSourceMetadataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSourceMetadataRead: async (documentId: string, documentFileId: string, documentFileSourceMetadataId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesSourceMetadataRead', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesSourceMetadataRead', 'documentFileId', documentFileId)
            // verify required parameter 'documentFileSourceMetadataId' is not null or undefined
            assertParamExists('documentsFilesSourceMetadataRead', 'documentFileSourceMetadataId', documentFileSourceMetadataId)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/source_metadata/{document_file_source_metadata_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)))
                .replace(`{${"document_file_source_metadata_id"}}`, encodeURIComponent(String(documentFileSourceMetadataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {DocumentFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesUpdate: async (documentId: string, documentFileId: string, data: DocumentFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsFilesUpdate', 'documentId', documentId)
            // verify required parameter 'documentFileId' is not null or undefined
            assertParamExists('documentsFilesUpdate', 'documentFileId', documentFileId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsFilesUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/files/{document_file_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_file_id"}}`, encodeURIComponent(String(documentFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the indexes instance nodes where this document is found.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIndexesList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsIndexesList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/indexes/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the documents.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsList: async (ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an existing metadata type and value to the selected document.
         * @param {string} documentId 
         * @param {DocumentMetadata} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataCreate: async (documentId: string, data: DocumentMetadata, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsMetadataCreate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsMetadataCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/metadata/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove this metadata entry from the selected document.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataDelete: async (documentId: string, metadataId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsMetadataDelete', 'documentId', documentId)
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('documentsMetadataDelete', 'metadataId', metadataId)
            const localVarPath = `/documents/{document_id}/metadata/{metadata_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"metadata_id"}}`, encodeURIComponent(String(metadataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of selected document\'s metadata types and values.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsMetadataList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/metadata/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the selected document metadata type and value.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {DocumentMetadata} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataPartialUpdate: async (documentId: string, metadataId: string, data: DocumentMetadata, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsMetadataPartialUpdate', 'documentId', documentId)
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('documentsMetadataPartialUpdate', 'metadataId', metadataId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsMetadataPartialUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/metadata/{metadata_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"metadata_id"}}`, encodeURIComponent(String(metadataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the details of the selected document metadata type and value.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataRead: async (documentId: string, metadataId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsMetadataRead', 'documentId', documentId)
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('documentsMetadataRead', 'metadataId', metadataId)
            const localVarPath = `/documents/{document_id}/metadata/{metadata_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"metadata_id"}}`, encodeURIComponent(String(metadataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the selected document metadata type and value.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {DocumentMetadata} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataUpdate: async (documentId: string, metadataId: string, data: DocumentMetadata, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsMetadataUpdate', 'documentId', documentId)
            // verify required parameter 'metadataId' is not null or undefined
            assertParamExists('documentsMetadataUpdate', 'metadataId', metadataId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsMetadataUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/metadata/{metadata_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"metadata_id"}}`, encodeURIComponent(String(metadataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a document for OCR.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsOcrSubmitCreate: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsOcrSubmitCreate', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/ocr/submit/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the properties of the selected document.
         * @param {string} documentId 
         * @param {Document} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsPartialUpdate: async (documentId: string, data: Document, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsPartialUpdate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsPartialUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the details of the selected document.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsRead: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsRead', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the smart link documents that apply to the document.
         * @param {string} documentId 
         * @param {string} resolvedSmartLinkId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedSmartLinksDocumentsList: async (documentId: string, resolvedSmartLinkId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsResolvedSmartLinksDocumentsList', 'documentId', documentId)
            // verify required parameter 'resolvedSmartLinkId' is not null or undefined
            assertParamExists('documentsResolvedSmartLinksDocumentsList', 'resolvedSmartLinkId', resolvedSmartLinkId)
            const localVarPath = `/documents/{document_id}/resolved_smart_links/{resolved_smart_link_id}/documents/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"resolved_smart_link_id"}}`, encodeURIComponent(String(resolvedSmartLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the smart links that apply to the document.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedSmartLinksList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsResolvedSmartLinksList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/resolved_smart_links/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the details of the selected resolved smart link.
         * @param {string} documentId 
         * @param {string} resolvedSmartLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedSmartLinksRead: async (documentId: string, resolvedSmartLinkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsResolvedSmartLinksRead', 'documentId', documentId)
            // verify required parameter 'resolvedSmartLinkId' is not null or undefined
            assertParamExists('documentsResolvedSmartLinksRead', 'resolvedSmartLinkId', resolvedSmartLinkId)
            const localVarPath = `/documents/{document_id}/resolved_smart_links/{resolved_smart_link_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"resolved_smart_link_id"}}`, encodeURIComponent(String(resolvedSmartLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of resolved web links for the specified document.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedWebLinksList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsResolvedWebLinksList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/resolved_web_links/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a redirection to the target URL of the selected resolved smart link.
         * @param {string} documentId 
         * @param {string} resolvedWebLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedWebLinksNavigateRead: async (documentId: string, resolvedWebLinkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsResolvedWebLinksNavigateRead', 'documentId', documentId)
            // verify required parameter 'resolvedWebLinkId' is not null or undefined
            assertParamExists('documentsResolvedWebLinksNavigateRead', 'resolvedWebLinkId', resolvedWebLinkId)
            const localVarPath = `/documents/{document_id}/resolved_web_links/{resolved_web_link_id}/navigate/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"resolved_web_link_id"}}`, encodeURIComponent(String(resolvedWebLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the details of the selected resolved smart link.
         * @param {string} documentId 
         * @param {string} resolvedWebLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedWebLinksRead: async (documentId: string, resolvedWebLinkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsResolvedWebLinksRead', 'documentId', documentId)
            // verify required parameter 'resolvedWebLinkId' is not null or undefined
            assertParamExists('documentsResolvedWebLinksRead', 'resolvedWebLinkId', resolvedWebLinkId)
            const localVarPath = `/documents/{document_id}/resolved_web_links/{resolved_web_link_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"resolved_web_link_id"}}`, encodeURIComponent(String(resolvedWebLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new signature_capture.
         * @param {string} documentId 
         * @param {SignatureCapture} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesCreate: async (documentId: string, data: SignatureCapture, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsSignatureCapturesCreate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsSignatureCapturesCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/signature_captures/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesDelete: async (documentId: string, signatureCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsSignatureCapturesDelete', 'documentId', documentId)
            // verify required parameter 'signatureCaptureId' is not null or undefined
            assertParamExists('documentsSignatureCapturesDelete', 'signatureCaptureId', signatureCaptureId)
            const localVarPath = `/documents/{document_id}/signature_captures/{signature_capture_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"signature_capture_id"}}`, encodeURIComponent(String(signatureCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an image representation of the selected signature capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesImageRead: async (documentId: string, signatureCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsSignatureCapturesImageRead', 'documentId', documentId)
            // verify required parameter 'signatureCaptureId' is not null or undefined
            assertParamExists('documentsSignatureCapturesImageRead', 'signatureCaptureId', signatureCaptureId)
            const localVarPath = `/documents/{document_id}/signature_captures/{signature_capture_id}/image/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"signature_capture_id"}}`, encodeURIComponent(String(signatureCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the signature_captures.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsSignatureCapturesList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/signature_captures/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {SignatureCapture} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesPartialUpdate: async (documentId: string, signatureCaptureId: string, data: SignatureCapture, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsSignatureCapturesPartialUpdate', 'documentId', documentId)
            // verify required parameter 'signatureCaptureId' is not null or undefined
            assertParamExists('documentsSignatureCapturesPartialUpdate', 'signatureCaptureId', signatureCaptureId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsSignatureCapturesPartialUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/signature_captures/{signature_capture_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"signature_capture_id"}}`, encodeURIComponent(String(signatureCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the details of the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesRead: async (documentId: string, signatureCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsSignatureCapturesRead', 'documentId', documentId)
            // verify required parameter 'signatureCaptureId' is not null or undefined
            assertParamExists('documentsSignatureCapturesRead', 'signatureCaptureId', signatureCaptureId)
            const localVarPath = `/documents/{document_id}/signature_captures/{signature_capture_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"signature_capture_id"}}`, encodeURIComponent(String(signatureCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {SignatureCapture} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesUpdate: async (documentId: string, signatureCaptureId: string, data: SignatureCapture, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsSignatureCapturesUpdate', 'documentId', documentId)
            // verify required parameter 'signatureCaptureId' is not null or undefined
            assertParamExists('documentsSignatureCapturesUpdate', 'signatureCaptureId', signatureCaptureId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsSignatureCapturesUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/signature_captures/{signature_capture_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"signature_capture_id"}}`, encodeURIComponent(String(signatureCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach a tag to a document.
         * @param {string} documentId 
         * @param {DocumentTagAttach} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsTagsAttachCreate: async (documentId: string, data: DocumentTagAttach, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsTagsAttachCreate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsTagsAttachCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/tags/attach/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the tags attached to a document.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsTagsList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsTagsList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/tags/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag from a document.
         * @param {string} documentId 
         * @param {DocumentTagRemove} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsTagsRemoveCreate: async (documentId: string, data: DocumentTagRemove, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsTagsRemoveCreate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsTagsRemoveCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/tags/remove/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the type of the selected document.
         * @param {string} documentId 
         * @param {DocumentChangeType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsTypeChangeCreate: async (documentId: string, data: DocumentChangeType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsTypeChangeCreate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsTypeChangeCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/type/change/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the properties of the selected document.
         * @param {string} documentId 
         * @param {Document} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsUpdate: async (documentId: string, data: Document, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsUpdate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document and a new document file.
         * @param {DocumentUpload} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsUploadCreate: async (data: DocumentUpload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsUploadCreate', 'data', data)
            const localVarPath = `/documents/upload/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document version.
         * @param {string} documentId 
         * @param {DocumentVersion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsCreate: async (documentId: string, data: DocumentVersion, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsCreate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsVersionsCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/versions/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsDelete: async (documentId: string, documentVersionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsDelete', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsDelete', 'documentVersionId', documentVersionId)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports the specified document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsExportCreate: async (documentId: string, documentVersionId: string, data: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsExportCreate', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsExportCreate', 'documentVersionId', documentVersionId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsVersionsExportCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/export/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of the selected document\'s versions.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/versions/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a modification backend on the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersionModificationExecute} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsModifyCreate: async (documentId: string, documentVersionId: string, data: DocumentVersionModificationExecute, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsModifyCreate', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsModifyCreate', 'documentVersionId', documentVersionId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsVersionsModifyCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/modify/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a document version for OCR.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsOcrSubmitCreate: async (documentId: string, documentVersionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsOcrSubmitCreate', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsOcrSubmitCreate', 'documentVersionId', documentVersionId)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/ocr/submit/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersionPage} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesCreate: async (documentId: string, documentVersionId: string, data: DocumentVersionPage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsPagesCreate', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsPagesCreate', 'documentVersionId', documentVersionId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsVersionsPagesCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/pages/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesDelete: async (documentId: string, documentVersionId: string, documentVersionPageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsPagesDelete', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsPagesDelete', 'documentVersionId', documentVersionId)
            // verify required parameter 'documentVersionPageId' is not null or undefined
            assertParamExists('documentsVersionsPagesDelete', 'documentVersionPageId', documentVersionPageId)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)))
                .replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(documentVersionPageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an image representation of the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesImageRead: async (documentId: string, documentVersionId: string, documentVersionPageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsPagesImageRead', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsPagesImageRead', 'documentVersionId', documentVersionId)
            // verify required parameter 'documentVersionPageId' is not null or undefined
            assertParamExists('documentsVersionsPagesImageRead', 'documentVersionPageId', documentVersionPageId)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/image/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)))
                .replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(documentVersionPageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an list of the pages for the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesList: async (documentId: string, documentVersionId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsPagesList', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsPagesList', 'documentVersionId', documentVersionId)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/pages/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the OCR content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPageOCRContent} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesOcrPartialUpdate: async (documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPageOCRContent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsPagesOcrPartialUpdate', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsPagesOcrPartialUpdate', 'documentVersionId', documentVersionId)
            // verify required parameter 'documentVersionPageId' is not null or undefined
            assertParamExists('documentsVersionsPagesOcrPartialUpdate', 'documentVersionPageId', documentVersionPageId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsVersionsPagesOcrPartialUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/ocr/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)))
                .replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(documentVersionPageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the OCR content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesOcrRead: async (documentId: string, documentVersionId: string, documentVersionPageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsPagesOcrRead', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsPagesOcrRead', 'documentVersionId', documentVersionId)
            // verify required parameter 'documentVersionPageId' is not null or undefined
            assertParamExists('documentsVersionsPagesOcrRead', 'documentVersionPageId', documentVersionPageId)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/ocr/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)))
                .replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(documentVersionPageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the OCR content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPageOCRContent} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesOcrUpdate: async (documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPageOCRContent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsPagesOcrUpdate', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsPagesOcrUpdate', 'documentVersionId', documentVersionId)
            // verify required parameter 'documentVersionPageId' is not null or undefined
            assertParamExists('documentsVersionsPagesOcrUpdate', 'documentVersionPageId', documentVersionPageId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsVersionsPagesOcrUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/ocr/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)))
                .replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(documentVersionPageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the properties of the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPage} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesPartialUpdate: async (documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsPagesPartialUpdate', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsPagesPartialUpdate', 'documentVersionId', documentVersionId)
            // verify required parameter 'documentVersionPageId' is not null or undefined
            assertParamExists('documentsVersionsPagesPartialUpdate', 'documentVersionPageId', documentVersionPageId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsVersionsPagesPartialUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)))
                .replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(documentVersionPageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the selected document version page details.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesRead: async (documentId: string, documentVersionId: string, documentVersionPageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsPagesRead', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsPagesRead', 'documentVersionId', documentVersionId)
            // verify required parameter 'documentVersionPageId' is not null or undefined
            assertParamExists('documentsVersionsPagesRead', 'documentVersionPageId', documentVersionPageId)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)))
                .replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(documentVersionPageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the properties of the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPage} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesUpdate: async (documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsPagesUpdate', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsPagesUpdate', 'documentVersionId', documentVersionId)
            // verify required parameter 'documentVersionPageId' is not null or undefined
            assertParamExists('documentsVersionsPagesUpdate', 'documentVersionPageId', documentVersionPageId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsVersionsPagesUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/pages/{document_version_page_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)))
                .replace(`{${"document_version_page_id"}}`, encodeURIComponent(String(documentVersionPageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the properties of the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPartialUpdate: async (documentId: string, documentVersionId: string, data: DocumentVersion, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsPartialUpdate', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsPartialUpdate', 'documentVersionId', documentVersionId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsVersionsPartialUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the selected document version details.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsRead: async (documentId: string, documentVersionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsRead', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsRead', 'documentVersionId', documentVersionId)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit the properties of the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsUpdate: async (documentId: string, documentVersionId: string, data: DocumentVersion, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsVersionsUpdate', 'documentId', documentId)
            // verify required parameter 'documentVersionId' is not null or undefined
            assertParamExists('documentsVersionsUpdate', 'documentVersionId', documentVersionId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsVersionsUpdate', 'data', data)
            const localVarPath = `/documents/{document_id}/versions/{document_version_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"document_version_id"}}`, encodeURIComponent(String(documentVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Launch a new workflow instance for the specified document.
         * @param {string} documentId 
         * @param {WorkflowInstanceLaunch} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesLaunchCreate: async (documentId: string, data: WorkflowInstanceLaunch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLaunchCreate', 'documentId', documentId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLaunchCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/workflow_instances/launch/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the document workflow instances.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesList: async (documentId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesList', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/workflow_instances/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transition a document workflow by creating a new document workflow instance log entry.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {WorkflowInstanceLogEntry} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesLogEntriesCreate: async (documentId: string, workflowInstanceId: string, data: WorkflowInstanceLogEntry, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLogEntriesCreate', 'documentId', documentId)
            // verify required parameter 'workflowInstanceId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLogEntriesCreate', 'workflowInstanceId', workflowInstanceId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLogEntriesCreate', 'data', data)
            const localVarPath = `/documents/{document_id}/workflow_instances/{workflow_instance_id}/log_entries/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"workflow_instance_id"}}`, encodeURIComponent(String(workflowInstanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the document workflow instances log entries.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesLogEntriesList: async (documentId: string, workflowInstanceId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLogEntriesList', 'documentId', documentId)
            // verify required parameter 'workflowInstanceId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLogEntriesList', 'workflowInstanceId', workflowInstanceId)
            const localVarPath = `/documents/{document_id}/workflow_instances/{workflow_instance_id}/log_entries/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"workflow_instance_id"}}`, encodeURIComponent(String(workflowInstanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the details of the selected document instances log entry.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {string} workflowInstanceLogEntryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesLogEntriesRead: async (documentId: string, workflowInstanceId: string, workflowInstanceLogEntryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLogEntriesRead', 'documentId', documentId)
            // verify required parameter 'workflowInstanceId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLogEntriesRead', 'workflowInstanceId', workflowInstanceId)
            // verify required parameter 'workflowInstanceLogEntryId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLogEntriesRead', 'workflowInstanceLogEntryId', workflowInstanceLogEntryId)
            const localVarPath = `/documents/{document_id}/workflow_instances/{workflow_instance_id}/log_entries/{workflow_instance_log_entry_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"workflow_instance_id"}}`, encodeURIComponent(String(workflowInstanceId)))
                .replace(`{${"workflow_instance_log_entry_id"}}`, encodeURIComponent(String(workflowInstanceLogEntryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all the possible transition choices for the workflow instance.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesLogEntriesTransitionsList: async (documentId: string, workflowInstanceId: string, ordering?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLogEntriesTransitionsList', 'documentId', documentId)
            // verify required parameter 'workflowInstanceId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesLogEntriesTransitionsList', 'workflowInstanceId', workflowInstanceId)
            const localVarPath = `/documents/{document_id}/workflow_instances/{workflow_instance_id}/log_entries/transitions/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"workflow_instance_id"}}`, encodeURIComponent(String(workflowInstanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (ordering !== undefined) {
                localVarQueryParameter['_ordering'] = ordering;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the details of the selected document workflow instances.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesRead: async (documentId: string, workflowInstanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesRead', 'documentId', documentId)
            // verify required parameter 'workflowInstanceId' is not null or undefined
            assertParamExists('documentsWorkflowInstancesRead', 'workflowInstanceId', workflowInstanceId)
            const localVarPath = `/documents/{document_id}/workflow_instances/{workflow_instance_id}/`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)))
                .replace(`{${"workflow_instance_id"}}`, encodeURIComponent(String(workflowInstanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Return a list of the recently accessed documents for the current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsAccessedList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsAccessedList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsAccessedList(ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsAccessedList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the cabinets to which a document belongs.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCabinetsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CabinetsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCabinetsList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCabinetsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check in the selected document.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCheckoutDelete(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCheckoutDelete(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCheckoutDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the checkout details of the selected document entry.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCheckoutRead(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentCheckout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCheckoutRead(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCheckoutRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new document comment.
         * @param {string} documentId 
         * @param {Comment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCommentsCreate(documentId: string, data: Comment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCommentsCreate(documentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCommentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the selected document comment.
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCommentsDelete(documentId: string, commentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCommentsDelete(documentId, commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCommentsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the document comments.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCommentsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsCommentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCommentsList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCommentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {Comment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCommentsPartialUpdate(documentId: string, commentId: string, data: Comment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCommentsPartialUpdate(documentId, commentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCommentsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the details of the selected document comment.
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCommentsRead(documentId: string, commentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCommentsRead(documentId, commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCommentsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {Comment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCommentsUpdate(documentId: string, commentId: string, data: Comment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCommentsUpdate(documentId, commentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCommentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new document.
         * @param {Document} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCreate(data: Document, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCreate(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of the recently created documents.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsCreatedList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CabinetsDocumentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsCreatedList(ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsCreatedList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move the selected document to the thrash.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsDelete(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDelete(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of duplicated documents.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsDuplicatedList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CabinetsDocumentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDuplicatedList(ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsDuplicatedList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of the selected document\'s duplicates.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsDuplicatesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsDuplicatesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDuplicatesList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsDuplicatesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new document to the list of favorite documents for the current user.
         * @param {FavoriteDocument} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFavoritesCreate(data: FavoriteDocument, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FavoriteDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFavoritesCreate(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFavoritesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the selected favorite document.
         * @param {string} favoriteDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFavoritesDelete(favoriteDocumentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFavoritesDelete(favoriteDocumentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFavoritesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of the favorite documents for the current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFavoritesList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsFavoritesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFavoritesList(ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFavoritesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the details of the selected favorite document.
         * @param {string} favoriteDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFavoritesRead(favoriteDocumentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FavoriteDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFavoritesRead(favoriteDocumentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFavoritesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new document file.
         * @param {string} documentId 
         * @param {DocumentFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesCreate(documentId: string, data: DocumentFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesCreate(documentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the selected document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesDelete(documentId: string, documentFileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesDelete(documentId, documentFileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesDownloadRead(documentId: string, documentFileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesDownloadRead(documentId, documentFileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesDownloadRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the list of file metadata entries for the selected driver.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} driverId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesFileMetadataDriversEntriesList(documentId: string, documentFileId: string, driverId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsFilesFileMetadataDriversEntriesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesFileMetadataDriversEntriesList(documentId, documentFileId, driverId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesFileMetadataDriversEntriesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the detail of selected document file metadata entry.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} driverId 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesFileMetadataDriversEntriesRead(documentId: string, documentFileId: string, driverId: string, entryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFileMetadataEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesFileMetadataDriversEntriesRead(documentId, documentFileId, driverId, entryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesFileMetadataDriversEntriesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of selected document\'s file metadata drivers.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesFileMetadataDriversList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsFilesFileMetadataDriversList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesFileMetadataDriversList(documentId, documentFileId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesFileMetadataDriversList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the details of the document file metadata driver.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} driverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesFileMetadataDriversRead(documentId: string, documentFileId: string, driverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFileMetadataDriverEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesFileMetadataDriversRead(documentId, documentFileId, driverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesFileMetadataDriversRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit a document file for file metadata processing.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesFileMetadataSubmitCreate(documentId: string, documentFileId: string, data: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesFileMetadataSubmitCreate(documentId, documentFileId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesFileMetadataSubmitCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of the selected document\'s files.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsFilesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFilePageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesPagesContentRead(documentId: string, documentFileId: string, documentFilePageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFilePageContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesPagesContentRead(documentId, documentFileId, documentFilePageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesPagesContentRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an image representation of the selected document.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFilePageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesPagesImageRead(documentId: string, documentFileId: string, documentFilePageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesPagesImageRead(documentId, documentFileId, documentFilePageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesPagesImageRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesPagesList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsFilesPagesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesPagesList(documentId, documentFileId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesPagesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the selected document page details.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFilePageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesPagesRead(documentId: string, documentFileId: string, documentFilePageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFilePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesPagesRead(documentId, documentFileId, documentFilePageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesPagesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {DocumentFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesPartialUpdate(documentId: string, documentFileId: string, data: DocumentFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesPartialUpdate(documentId, documentFileId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the selected document file details.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesRead(documentId: string, documentFileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesRead(documentId, documentFileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an detached signature of the selected document.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} detachedSignatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesSignaturesDetachedDelete(documentId: string, documentFileId: string, detachedSignatureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesSignaturesDetachedDelete(documentId, documentFileId, detachedSignatureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesSignaturesDetachedDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the detached signatures of a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesSignaturesDetachedList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsFilesSignaturesDetachedList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesSignaturesDetachedList(documentId, documentFileId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesSignaturesDetachedList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the details of the selected detached signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} detachedSignatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesSignaturesDetachedRead(documentId: string, documentFileId: string, detachedSignatureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetachedSignature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesSignaturesDetachedRead(documentId, documentFileId, detachedSignatureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesSignaturesDetachedRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sign a document file with a detached signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {SignDetached} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesSignaturesDetachedSignCreate(documentId: string, documentFileId: string, data: SignDetached, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignDetached>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesSignaturesDetachedSignCreate(documentId, documentFileId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesSignaturesDetachedSignCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a detached signature file for a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {DetachedSignatureUpload} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesSignaturesDetachedUploadCreate(documentId: string, documentFileId: string, data: DetachedSignatureUpload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetachedSignatureUpload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesSignaturesDetachedUploadCreate(documentId, documentFileId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesSignaturesDetachedUploadCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the embedded signatures of a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesSignaturesEmbeddedList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsFilesSignaturesEmbeddedList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesSignaturesEmbeddedList(documentId, documentFileId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesSignaturesEmbeddedList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the details of the selected embedded signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} embeddedSignatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesSignaturesEmbeddedRead(documentId: string, documentFileId: string, embeddedSignatureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmbeddedSignature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesSignaturesEmbeddedRead(documentId, documentFileId, embeddedSignatureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesSignaturesEmbeddedRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sign a document file with an embedded signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {SignEmbedded} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesSignaturesEmbeddedSignCreate(documentId: string, documentFileId: string, data: SignEmbedded, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignEmbedded>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesSignaturesEmbeddedSignCreate(documentId, documentFileId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesSignaturesEmbeddedSignCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of selected document\'s source metadata values.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesSourceMetadataList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsFilesSourceMetadataList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesSourceMetadataList(documentId, documentFileId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesSourceMetadataList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the details of the selected document source metadata.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFileSourceMetadataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesSourceMetadataRead(documentId: string, documentFileId: string, documentFileSourceMetadataId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFileSourceMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesSourceMetadataRead(documentId, documentFileId, documentFileSourceMetadataId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesSourceMetadataRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {DocumentFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsFilesUpdate(documentId: string, documentFileId: string, data: DocumentFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsFilesUpdate(documentId, documentFileId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsFilesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the indexes instance nodes where this document is found.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsIndexesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsIndexesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsIndexesList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsIndexesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the documents.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CabinetsDocumentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsList(ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add an existing metadata type and value to the selected document.
         * @param {string} documentId 
         * @param {DocumentMetadata} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsMetadataCreate(documentId: string, data: DocumentMetadata, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsMetadataCreate(documentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsMetadataCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove this metadata entry from the selected document.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsMetadataDelete(documentId: string, metadataId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsMetadataDelete(documentId, metadataId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsMetadataDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of selected document\'s metadata types and values.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsMetadataList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsMetadataList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsMetadataList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsMetadataList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the selected document metadata type and value.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {DocumentMetadata} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsMetadataPartialUpdate(documentId: string, metadataId: string, data: DocumentMetadata, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsMetadataPartialUpdate(documentId, metadataId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsMetadataPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the details of the selected document metadata type and value.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsMetadataRead(documentId: string, metadataId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsMetadataRead(documentId, metadataId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsMetadataRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the selected document metadata type and value.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {DocumentMetadata} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsMetadataUpdate(documentId: string, metadataId: string, data: DocumentMetadata, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsMetadataUpdate(documentId, metadataId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsMetadataUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit a document for OCR.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsOcrSubmitCreate(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsOcrSubmitCreate(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsOcrSubmitCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the properties of the selected document.
         * @param {string} documentId 
         * @param {Document} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsPartialUpdate(documentId: string, data: Document, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsPartialUpdate(documentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the details of the selected document.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsRead(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsRead(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the smart link documents that apply to the document.
         * @param {string} documentId 
         * @param {string} resolvedSmartLinkId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsResolvedSmartLinksDocumentsList(documentId: string, resolvedSmartLinkId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsResolvedSmartLinksDocumentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsResolvedSmartLinksDocumentsList(documentId, resolvedSmartLinkId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsResolvedSmartLinksDocumentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of the smart links that apply to the document.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsResolvedSmartLinksList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsResolvedSmartLinksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsResolvedSmartLinksList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsResolvedSmartLinksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the details of the selected resolved smart link.
         * @param {string} documentId 
         * @param {string} resolvedSmartLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsResolvedSmartLinksRead(documentId: string, resolvedSmartLinkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolvedSmartLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsResolvedSmartLinksRead(documentId, resolvedSmartLinkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsResolvedSmartLinksRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of resolved web links for the specified document.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsResolvedWebLinksList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsResolvedWebLinksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsResolvedWebLinksList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsResolvedWebLinksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform a redirection to the target URL of the selected resolved smart link.
         * @param {string} documentId 
         * @param {string} resolvedWebLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsResolvedWebLinksNavigateRead(documentId: string, resolvedWebLinkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsResolvedWebLinksNavigateRead(documentId, resolvedWebLinkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsResolvedWebLinksNavigateRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the details of the selected resolved smart link.
         * @param {string} documentId 
         * @param {string} resolvedWebLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsResolvedWebLinksRead(documentId: string, resolvedWebLinkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolvedWebLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsResolvedWebLinksRead(documentId, resolvedWebLinkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsResolvedWebLinksRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new signature_capture.
         * @param {string} documentId 
         * @param {SignatureCapture} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsSignatureCapturesCreate(documentId: string, data: SignatureCapture, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignatureCapture>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsSignatureCapturesCreate(documentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsSignatureCapturesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsSignatureCapturesDelete(documentId: string, signatureCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsSignatureCapturesDelete(documentId, signatureCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsSignatureCapturesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an image representation of the selected signature capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsSignatureCapturesImageRead(documentId: string, signatureCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsSignatureCapturesImageRead(documentId, signatureCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsSignatureCapturesImageRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the signature_captures.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsSignatureCapturesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsSignatureCapturesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsSignatureCapturesList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsSignatureCapturesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {SignatureCapture} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsSignatureCapturesPartialUpdate(documentId: string, signatureCaptureId: string, data: SignatureCapture, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignatureCapture>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsSignatureCapturesPartialUpdate(documentId, signatureCaptureId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsSignatureCapturesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the details of the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsSignatureCapturesRead(documentId: string, signatureCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignatureCapture>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsSignatureCapturesRead(documentId, signatureCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsSignatureCapturesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {SignatureCapture} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsSignatureCapturesUpdate(documentId: string, signatureCaptureId: string, data: SignatureCapture, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignatureCapture>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsSignatureCapturesUpdate(documentId, signatureCaptureId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsSignatureCapturesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach a tag to a document.
         * @param {string} documentId 
         * @param {DocumentTagAttach} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsTagsAttachCreate(documentId: string, data: DocumentTagAttach, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTagAttach>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsTagsAttachCreate(documentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsTagsAttachCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the tags attached to a document.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsTagsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsTagsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsTagsList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsTagsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a tag from a document.
         * @param {string} documentId 
         * @param {DocumentTagRemove} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsTagsRemoveCreate(documentId: string, data: DocumentTagRemove, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTagRemove>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsTagsRemoveCreate(documentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsTagsRemoveCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change the type of the selected document.
         * @param {string} documentId 
         * @param {DocumentChangeType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsTypeChangeCreate(documentId: string, data: DocumentChangeType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentChangeType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsTypeChangeCreate(documentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsTypeChangeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the properties of the selected document.
         * @param {string} documentId 
         * @param {Document} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsUpdate(documentId: string, data: Document, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsUpdate(documentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new document and a new document file.
         * @param {DocumentUpload} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsUploadCreate(data: DocumentUpload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUpload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsUploadCreate(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsUploadCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new document version.
         * @param {string} documentId 
         * @param {DocumentVersion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsCreate(documentId: string, data: DocumentVersion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsCreate(documentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsDelete(documentId: string, documentVersionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsDelete(documentId, documentVersionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exports the specified document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsExportCreate(documentId: string, documentVersionId: string, data: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsExportCreate(documentId, documentVersionId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsExportCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of the selected document\'s versions.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsVersionsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute a modification backend on the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersionModificationExecute} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsModifyCreate(documentId: string, documentVersionId: string, data: DocumentVersionModificationExecute, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersionModificationExecute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsModifyCreate(documentId, documentVersionId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsModifyCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit a document version for OCR.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsOcrSubmitCreate(documentId: string, documentVersionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsOcrSubmitCreate(documentId, documentVersionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsOcrSubmitCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersionPage} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsPagesCreate(documentId: string, documentVersionId: string, data: DocumentVersionPage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsPagesCreate(documentId, documentVersionId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsPagesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsPagesDelete(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsPagesDelete(documentId, documentVersionId, documentVersionPageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsPagesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an image representation of the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsPagesImageRead(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsPagesImageRead(documentId, documentVersionId, documentVersionPageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsPagesImageRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an list of the pages for the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsPagesList(documentId: string, documentVersionId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsVersionsPagesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsPagesList(documentId, documentVersionId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsPagesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the OCR content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPageOCRContent} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsPagesOcrPartialUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPageOCRContent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersionPageOCRContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsPagesOcrPartialUpdate(documentId, documentVersionId, documentVersionPageId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsPagesOcrPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the OCR content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsPagesOcrRead(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersionPageOCRContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsPagesOcrRead(documentId, documentVersionId, documentVersionPageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsPagesOcrRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the OCR content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPageOCRContent} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsPagesOcrUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPageOCRContent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersionPageOCRContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsPagesOcrUpdate(documentId, documentVersionId, documentVersionPageId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsPagesOcrUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the properties of the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPage} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsPagesPartialUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsPagesPartialUpdate(documentId, documentVersionId, documentVersionPageId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsPagesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the selected document version page details.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsPagesRead(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsPagesRead(documentId, documentVersionId, documentVersionPageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsPagesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the properties of the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPage} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsPagesUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsPagesUpdate(documentId, documentVersionId, documentVersionPageId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsPagesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the properties of the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsPartialUpdate(documentId: string, documentVersionId: string, data: DocumentVersion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsPartialUpdate(documentId, documentVersionId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the selected document version details.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsRead(documentId: string, documentVersionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsRead(documentId, documentVersionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit the properties of the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsVersionsUpdate(documentId: string, documentVersionId: string, data: DocumentVersion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsVersionsUpdate(documentId, documentVersionId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsVersionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Launch a new workflow instance for the specified document.
         * @param {string} documentId 
         * @param {WorkflowInstanceLaunch} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsWorkflowInstancesLaunchCreate(documentId: string, data: WorkflowInstanceLaunch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowInstanceLaunch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsWorkflowInstancesLaunchCreate(documentId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsWorkflowInstancesLaunchCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the document workflow instances.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsWorkflowInstancesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsWorkflowInstancesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsWorkflowInstancesList(documentId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsWorkflowInstancesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transition a document workflow by creating a new document workflow instance log entry.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {WorkflowInstanceLogEntry} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsWorkflowInstancesLogEntriesCreate(documentId: string, workflowInstanceId: string, data: WorkflowInstanceLogEntry, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowInstanceLogEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsWorkflowInstancesLogEntriesCreate(documentId, workflowInstanceId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsWorkflowInstancesLogEntriesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the document workflow instances log entries.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsWorkflowInstancesLogEntriesList(documentId: string, workflowInstanceId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsWorkflowInstancesLogEntriesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsWorkflowInstancesLogEntriesList(documentId, workflowInstanceId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsWorkflowInstancesLogEntriesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the details of the selected document instances log entry.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {string} workflowInstanceLogEntryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsWorkflowInstancesLogEntriesRead(documentId: string, workflowInstanceId: string, workflowInstanceLogEntryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowInstanceLogEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsWorkflowInstancesLogEntriesRead(documentId, workflowInstanceId, workflowInstanceLogEntryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsWorkflowInstancesLogEntriesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all the possible transition choices for the workflow instance.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsWorkflowInstancesLogEntriesTransitionsList(documentId: string, workflowInstanceId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsWorkflowInstancesLogEntriesTransitionsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsWorkflowInstancesLogEntriesTransitionsList(documentId, workflowInstanceId, ordering, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsWorkflowInstancesLogEntriesTransitionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the details of the selected document workflow instances.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsWorkflowInstancesRead(documentId: string, workflowInstanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsWorkflowInstancesRead(documentId, workflowInstanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.documentsWorkflowInstancesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Return a list of the recently accessed documents for the current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsAccessedList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsAccessedList200Response> {
            return localVarFp.documentsAccessedList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the cabinets to which a document belongs.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCabinetsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<CabinetsList200Response> {
            return localVarFp.documentsCabinetsList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Check in the selected document.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCheckoutDelete(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsCheckoutDelete(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the checkout details of the selected document entry.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCheckoutRead(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentCheckout> {
            return localVarFp.documentsCheckoutRead(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document comment.
         * @param {string} documentId 
         * @param {Comment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsCreate(documentId: string, data: Comment, options?: RawAxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.documentsCommentsCreate(documentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the selected document comment.
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsDelete(documentId: string, commentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsCommentsDelete(documentId, commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the document comments.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsCommentsList200Response> {
            return localVarFp.documentsCommentsList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {Comment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsPartialUpdate(documentId: string, commentId: string, data: Comment, options?: RawAxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.documentsCommentsPartialUpdate(documentId, commentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of the selected document comment.
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsRead(documentId: string, commentId: string, options?: RawAxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.documentsCommentsRead(documentId, commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} commentId 
         * @param {Comment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCommentsUpdate(documentId: string, commentId: string, data: Comment, options?: RawAxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.documentsCommentsUpdate(documentId, commentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document.
         * @param {Document} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCreate(data: Document, options?: RawAxiosRequestConfig): AxiosPromise<Document> {
            return localVarFp.documentsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of the recently created documents.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsCreatedList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<CabinetsDocumentsList200Response> {
            return localVarFp.documentsCreatedList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Move the selected document to the thrash.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDelete(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsDelete(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of duplicated documents.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDuplicatedList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<CabinetsDocumentsList200Response> {
            return localVarFp.documentsDuplicatedList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of the selected document\'s duplicates.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDuplicatesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsDuplicatesList200Response> {
            return localVarFp.documentsDuplicatesList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new document to the list of favorite documents for the current user.
         * @param {FavoriteDocument} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFavoritesCreate(data: FavoriteDocument, options?: RawAxiosRequestConfig): AxiosPromise<FavoriteDocument> {
            return localVarFp.documentsFavoritesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the selected favorite document.
         * @param {string} favoriteDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFavoritesDelete(favoriteDocumentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsFavoritesDelete(favoriteDocumentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of the favorite documents for the current user.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFavoritesList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsFavoritesList200Response> {
            return localVarFp.documentsFavoritesList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the details of the selected favorite document.
         * @param {string} favoriteDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFavoritesRead(favoriteDocumentId: string, options?: RawAxiosRequestConfig): AxiosPromise<FavoriteDocument> {
            return localVarFp.documentsFavoritesRead(favoriteDocumentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document file.
         * @param {string} documentId 
         * @param {DocumentFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesCreate(documentId: string, data: DocumentFile, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFile> {
            return localVarFp.documentsFilesCreate(documentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the selected document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesDelete(documentId: string, documentFileId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsFilesDelete(documentId, documentFileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesDownloadRead(documentId: string, documentFileId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsFilesDownloadRead(documentId, documentFileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the list of file metadata entries for the selected driver.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} driverId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesFileMetadataDriversEntriesList(documentId: string, documentFileId: string, driverId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsFilesFileMetadataDriversEntriesList200Response> {
            return localVarFp.documentsFilesFileMetadataDriversEntriesList(documentId, documentFileId, driverId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the detail of selected document file metadata entry.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} driverId 
         * @param {string} entryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesFileMetadataDriversEntriesRead(documentId: string, documentFileId: string, driverId: string, entryId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFileMetadataEntry> {
            return localVarFp.documentsFilesFileMetadataDriversEntriesRead(documentId, documentFileId, driverId, entryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of selected document\'s file metadata drivers.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesFileMetadataDriversList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsFilesFileMetadataDriversList200Response> {
            return localVarFp.documentsFilesFileMetadataDriversList(documentId, documentFileId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of the document file metadata driver.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} driverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesFileMetadataDriversRead(documentId: string, documentFileId: string, driverId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFileMetadataDriverEntry> {
            return localVarFp.documentsFilesFileMetadataDriversRead(documentId, documentFileId, driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a document file for file metadata processing.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesFileMetadataSubmitCreate(documentId: string, documentFileId: string, data: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentsFilesFileMetadataSubmitCreate(documentId, documentFileId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of the selected document\'s files.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsFilesList200Response> {
            return localVarFp.documentsFilesList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFilePageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesPagesContentRead(documentId: string, documentFileId: string, documentFilePageId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFilePageContent> {
            return localVarFp.documentsFilesPagesContentRead(documentId, documentFileId, documentFilePageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an image representation of the selected document.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFilePageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesPagesImageRead(documentId: string, documentFileId: string, documentFilePageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsFilesPagesImageRead(documentId, documentFileId, documentFilePageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesPagesList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsFilesPagesList200Response> {
            return localVarFp.documentsFilesPagesList(documentId, documentFileId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the selected document page details.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFilePageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesPagesRead(documentId: string, documentFileId: string, documentFilePageId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFilePage> {
            return localVarFp.documentsFilesPagesRead(documentId, documentFileId, documentFilePageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {DocumentFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesPartialUpdate(documentId: string, documentFileId: string, data: DocumentFile, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFile> {
            return localVarFp.documentsFilesPartialUpdate(documentId, documentFileId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the selected document file details.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesRead(documentId: string, documentFileId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFile> {
            return localVarFp.documentsFilesRead(documentId, documentFileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an detached signature of the selected document.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} detachedSignatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesDetachedDelete(documentId: string, documentFileId: string, detachedSignatureId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsFilesSignaturesDetachedDelete(documentId, documentFileId, detachedSignatureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the detached signatures of a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesDetachedList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsFilesSignaturesDetachedList200Response> {
            return localVarFp.documentsFilesSignaturesDetachedList(documentId, documentFileId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of the selected detached signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} detachedSignatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesDetachedRead(documentId: string, documentFileId: string, detachedSignatureId: string, options?: RawAxiosRequestConfig): AxiosPromise<DetachedSignature> {
            return localVarFp.documentsFilesSignaturesDetachedRead(documentId, documentFileId, detachedSignatureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sign a document file with a detached signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {SignDetached} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesDetachedSignCreate(documentId: string, documentFileId: string, data: SignDetached, options?: RawAxiosRequestConfig): AxiosPromise<SignDetached> {
            return localVarFp.documentsFilesSignaturesDetachedSignCreate(documentId, documentFileId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a detached signature file for a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {DetachedSignatureUpload} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesDetachedUploadCreate(documentId: string, documentFileId: string, data: DetachedSignatureUpload, options?: RawAxiosRequestConfig): AxiosPromise<DetachedSignatureUpload> {
            return localVarFp.documentsFilesSignaturesDetachedUploadCreate(documentId, documentFileId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the embedded signatures of a document file.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesEmbeddedList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsFilesSignaturesEmbeddedList200Response> {
            return localVarFp.documentsFilesSignaturesEmbeddedList(documentId, documentFileId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of the selected embedded signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} embeddedSignatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesEmbeddedRead(documentId: string, documentFileId: string, embeddedSignatureId: string, options?: RawAxiosRequestConfig): AxiosPromise<EmbeddedSignature> {
            return localVarFp.documentsFilesSignaturesEmbeddedRead(documentId, documentFileId, embeddedSignatureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sign a document file with an embedded signature.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {SignEmbedded} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSignaturesEmbeddedSignCreate(documentId: string, documentFileId: string, data: SignEmbedded, options?: RawAxiosRequestConfig): AxiosPromise<SignEmbedded> {
            return localVarFp.documentsFilesSignaturesEmbeddedSignCreate(documentId, documentFileId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of selected document\'s source metadata values.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSourceMetadataList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsFilesSourceMetadataList200Response> {
            return localVarFp.documentsFilesSourceMetadataList(documentId, documentFileId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the details of the selected document source metadata.
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {string} documentFileSourceMetadataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesSourceMetadataRead(documentId: string, documentFileId: string, documentFileSourceMetadataId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFileSourceMetadata> {
            return localVarFp.documentsFilesSourceMetadataRead(documentId, documentFileId, documentFileSourceMetadataId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentId 
         * @param {string} documentFileId 
         * @param {DocumentFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsFilesUpdate(documentId: string, documentFileId: string, data: DocumentFile, options?: RawAxiosRequestConfig): AxiosPromise<DocumentFile> {
            return localVarFp.documentsFilesUpdate(documentId, documentFileId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the indexes instance nodes where this document is found.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsIndexesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsIndexesList200Response> {
            return localVarFp.documentsIndexesList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the documents.
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<CabinetsDocumentsList200Response> {
            return localVarFp.documentsList(ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an existing metadata type and value to the selected document.
         * @param {string} documentId 
         * @param {DocumentMetadata} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataCreate(documentId: string, data: DocumentMetadata, options?: RawAxiosRequestConfig): AxiosPromise<DocumentMetadata> {
            return localVarFp.documentsMetadataCreate(documentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove this metadata entry from the selected document.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataDelete(documentId: string, metadataId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsMetadataDelete(documentId, metadataId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of selected document\'s metadata types and values.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsMetadataList200Response> {
            return localVarFp.documentsMetadataList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the selected document metadata type and value.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {DocumentMetadata} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataPartialUpdate(documentId: string, metadataId: string, data: DocumentMetadata, options?: RawAxiosRequestConfig): AxiosPromise<DocumentMetadata> {
            return localVarFp.documentsMetadataPartialUpdate(documentId, metadataId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the details of the selected document metadata type and value.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataRead(documentId: string, metadataId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentMetadata> {
            return localVarFp.documentsMetadataRead(documentId, metadataId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the selected document metadata type and value.
         * @param {string} documentId 
         * @param {string} metadataId 
         * @param {DocumentMetadata} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMetadataUpdate(documentId: string, metadataId: string, data: DocumentMetadata, options?: RawAxiosRequestConfig): AxiosPromise<DocumentMetadata> {
            return localVarFp.documentsMetadataUpdate(documentId, metadataId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a document for OCR.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsOcrSubmitCreate(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsOcrSubmitCreate(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the properties of the selected document.
         * @param {string} documentId 
         * @param {Document} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsPartialUpdate(documentId: string, data: Document, options?: RawAxiosRequestConfig): AxiosPromise<Document> {
            return localVarFp.documentsPartialUpdate(documentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the details of the selected document.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsRead(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<Document> {
            return localVarFp.documentsRead(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the smart link documents that apply to the document.
         * @param {string} documentId 
         * @param {string} resolvedSmartLinkId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedSmartLinksDocumentsList(documentId: string, resolvedSmartLinkId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsResolvedSmartLinksDocumentsList200Response> {
            return localVarFp.documentsResolvedSmartLinksDocumentsList(documentId, resolvedSmartLinkId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the smart links that apply to the document.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedSmartLinksList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsResolvedSmartLinksList200Response> {
            return localVarFp.documentsResolvedSmartLinksList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the details of the selected resolved smart link.
         * @param {string} documentId 
         * @param {string} resolvedSmartLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedSmartLinksRead(documentId: string, resolvedSmartLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResolvedSmartLink> {
            return localVarFp.documentsResolvedSmartLinksRead(documentId, resolvedSmartLinkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of resolved web links for the specified document.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedWebLinksList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsResolvedWebLinksList200Response> {
            return localVarFp.documentsResolvedWebLinksList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a redirection to the target URL of the selected resolved smart link.
         * @param {string} documentId 
         * @param {string} resolvedWebLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedWebLinksNavigateRead(documentId: string, resolvedWebLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentsResolvedWebLinksNavigateRead(documentId, resolvedWebLinkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the details of the selected resolved smart link.
         * @param {string} documentId 
         * @param {string} resolvedWebLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsResolvedWebLinksRead(documentId: string, resolvedWebLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResolvedWebLink> {
            return localVarFp.documentsResolvedWebLinksRead(documentId, resolvedWebLinkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new signature_capture.
         * @param {string} documentId 
         * @param {SignatureCapture} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesCreate(documentId: string, data: SignatureCapture, options?: RawAxiosRequestConfig): AxiosPromise<SignatureCapture> {
            return localVarFp.documentsSignatureCapturesCreate(documentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesDelete(documentId: string, signatureCaptureId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsSignatureCapturesDelete(documentId, signatureCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an image representation of the selected signature capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesImageRead(documentId: string, signatureCaptureId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsSignatureCapturesImageRead(documentId, signatureCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the signature_captures.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsSignatureCapturesList200Response> {
            return localVarFp.documentsSignatureCapturesList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {SignatureCapture} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesPartialUpdate(documentId: string, signatureCaptureId: string, data: SignatureCapture, options?: RawAxiosRequestConfig): AxiosPromise<SignatureCapture> {
            return localVarFp.documentsSignatureCapturesPartialUpdate(documentId, signatureCaptureId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the details of the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesRead(documentId: string, signatureCaptureId: string, options?: RawAxiosRequestConfig): AxiosPromise<SignatureCapture> {
            return localVarFp.documentsSignatureCapturesRead(documentId, signatureCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the selected signature_capture.
         * @param {string} documentId 
         * @param {string} signatureCaptureId 
         * @param {SignatureCapture} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsSignatureCapturesUpdate(documentId: string, signatureCaptureId: string, data: SignatureCapture, options?: RawAxiosRequestConfig): AxiosPromise<SignatureCapture> {
            return localVarFp.documentsSignatureCapturesUpdate(documentId, signatureCaptureId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach a tag to a document.
         * @param {string} documentId 
         * @param {DocumentTagAttach} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsTagsAttachCreate(documentId: string, data: DocumentTagAttach, options?: RawAxiosRequestConfig): AxiosPromise<DocumentTagAttach> {
            return localVarFp.documentsTagsAttachCreate(documentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the tags attached to a document.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsTagsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsTagsList200Response> {
            return localVarFp.documentsTagsList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag from a document.
         * @param {string} documentId 
         * @param {DocumentTagRemove} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsTagsRemoveCreate(documentId: string, data: DocumentTagRemove, options?: RawAxiosRequestConfig): AxiosPromise<DocumentTagRemove> {
            return localVarFp.documentsTagsRemoveCreate(documentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Change the type of the selected document.
         * @param {string} documentId 
         * @param {DocumentChangeType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsTypeChangeCreate(documentId: string, data: DocumentChangeType, options?: RawAxiosRequestConfig): AxiosPromise<DocumentChangeType> {
            return localVarFp.documentsTypeChangeCreate(documentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the properties of the selected document.
         * @param {string} documentId 
         * @param {Document} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsUpdate(documentId: string, data: Document, options?: RawAxiosRequestConfig): AxiosPromise<Document> {
            return localVarFp.documentsUpdate(documentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document and a new document file.
         * @param {DocumentUpload} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsUploadCreate(data: DocumentUpload, options?: RawAxiosRequestConfig): AxiosPromise<DocumentUpload> {
            return localVarFp.documentsUploadCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document version.
         * @param {string} documentId 
         * @param {DocumentVersion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsCreate(documentId: string, data: DocumentVersion, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersion> {
            return localVarFp.documentsVersionsCreate(documentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsDelete(documentId: string, documentVersionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsVersionsDelete(documentId, documentVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Exports the specified document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsExportCreate(documentId: string, documentVersionId: string, data: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.documentsVersionsExportCreate(documentId, documentVersionId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of the selected document\'s versions.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsVersionsList200Response> {
            return localVarFp.documentsVersionsList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute a modification backend on the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersionModificationExecute} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsModifyCreate(documentId: string, documentVersionId: string, data: DocumentVersionModificationExecute, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersionModificationExecute> {
            return localVarFp.documentsVersionsModifyCreate(documentId, documentVersionId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a document version for OCR.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsOcrSubmitCreate(documentId: string, documentVersionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsVersionsOcrSubmitCreate(documentId, documentVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersionPage} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesCreate(documentId: string, documentVersionId: string, data: DocumentVersionPage, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersionPage> {
            return localVarFp.documentsVersionsPagesCreate(documentId, documentVersionId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesDelete(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsVersionsPagesDelete(documentId, documentVersionId, documentVersionPageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an image representation of the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesImageRead(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.documentsVersionsPagesImageRead(documentId, documentVersionId, documentVersionPageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an list of the pages for the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesList(documentId: string, documentVersionId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsVersionsPagesList200Response> {
            return localVarFp.documentsVersionsPagesList(documentId, documentVersionId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the OCR content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPageOCRContent} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesOcrPartialUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPageOCRContent, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersionPageOCRContent> {
            return localVarFp.documentsVersionsPagesOcrPartialUpdate(documentId, documentVersionId, documentVersionPageId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the OCR content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesOcrRead(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersionPageOCRContent> {
            return localVarFp.documentsVersionsPagesOcrRead(documentId, documentVersionId, documentVersionPageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the OCR content of the selected document page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPageOCRContent} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesOcrUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPageOCRContent, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersionPageOCRContent> {
            return localVarFp.documentsVersionsPagesOcrUpdate(documentId, documentVersionId, documentVersionPageId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the properties of the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPage} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesPartialUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPage, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersionPage> {
            return localVarFp.documentsVersionsPagesPartialUpdate(documentId, documentVersionId, documentVersionPageId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the selected document version page details.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesRead(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersionPage> {
            return localVarFp.documentsVersionsPagesRead(documentId, documentVersionId, documentVersionPageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the properties of the selected document version page.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {string} documentVersionPageId 
         * @param {DocumentVersionPage} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPagesUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPage, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersionPage> {
            return localVarFp.documentsVersionsPagesUpdate(documentId, documentVersionId, documentVersionPageId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the properties of the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsPartialUpdate(documentId: string, documentVersionId: string, data: DocumentVersion, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersion> {
            return localVarFp.documentsVersionsPartialUpdate(documentId, documentVersionId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the selected document version details.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsRead(documentId: string, documentVersionId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersion> {
            return localVarFp.documentsVersionsRead(documentId, documentVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit the properties of the selected document version.
         * @param {string} documentId 
         * @param {string} documentVersionId 
         * @param {DocumentVersion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsVersionsUpdate(documentId: string, documentVersionId: string, data: DocumentVersion, options?: RawAxiosRequestConfig): AxiosPromise<DocumentVersion> {
            return localVarFp.documentsVersionsUpdate(documentId, documentVersionId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Launch a new workflow instance for the specified document.
         * @param {string} documentId 
         * @param {WorkflowInstanceLaunch} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesLaunchCreate(documentId: string, data: WorkflowInstanceLaunch, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowInstanceLaunch> {
            return localVarFp.documentsWorkflowInstancesLaunchCreate(documentId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the document workflow instances.
         * @param {string} documentId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsWorkflowInstancesList200Response> {
            return localVarFp.documentsWorkflowInstancesList(documentId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Transition a document workflow by creating a new document workflow instance log entry.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {WorkflowInstanceLogEntry} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesLogEntriesCreate(documentId: string, workflowInstanceId: string, data: WorkflowInstanceLogEntry, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowInstanceLogEntry> {
            return localVarFp.documentsWorkflowInstancesLogEntriesCreate(documentId, workflowInstanceId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the document workflow instances log entries.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesLogEntriesList(documentId: string, workflowInstanceId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsWorkflowInstancesLogEntriesList200Response> {
            return localVarFp.documentsWorkflowInstancesLogEntriesList(documentId, workflowInstanceId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the details of the selected document instances log entry.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {string} workflowInstanceLogEntryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesLogEntriesRead(documentId: string, workflowInstanceId: string, workflowInstanceLogEntryId: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowInstanceLogEntry> {
            return localVarFp.documentsWorkflowInstancesLogEntriesRead(documentId, workflowInstanceId, workflowInstanceLogEntryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all the possible transition choices for the workflow instance.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesLogEntriesTransitionsList(documentId: string, workflowInstanceId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsWorkflowInstancesLogEntriesTransitionsList200Response> {
            return localVarFp.documentsWorkflowInstancesLogEntriesTransitionsList(documentId, workflowInstanceId, ordering, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the details of the selected document workflow instances.
         * @param {string} documentId 
         * @param {string} workflowInstanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsWorkflowInstancesRead(documentId: string, workflowInstanceId: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowInstance> {
            return localVarFp.documentsWorkflowInstancesRead(documentId, workflowInstanceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Return a list of the recently accessed documents for the current user.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsAccessedList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsAccessedList(ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the cabinets to which a document belongs.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCabinetsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCabinetsList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check in the selected document.
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCheckoutDelete(documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCheckoutDelete(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the checkout details of the selected document entry.
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCheckoutRead(documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCheckoutRead(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document comment.
     * @param {string} documentId 
     * @param {Comment} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCommentsCreate(documentId: string, data: Comment, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCommentsCreate(documentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the selected document comment.
     * @param {string} documentId 
     * @param {string} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCommentsDelete(documentId: string, commentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCommentsDelete(documentId, commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the document comments.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCommentsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCommentsList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentId 
     * @param {string} commentId 
     * @param {Comment} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCommentsPartialUpdate(documentId: string, commentId: string, data: Comment, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCommentsPartialUpdate(documentId, commentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of the selected document comment.
     * @param {string} documentId 
     * @param {string} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCommentsRead(documentId: string, commentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCommentsRead(documentId, commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentId 
     * @param {string} commentId 
     * @param {Comment} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCommentsUpdate(documentId: string, commentId: string, data: Comment, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCommentsUpdate(documentId, commentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document.
     * @param {Document} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCreate(data: Document, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of the recently created documents.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsCreatedList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsCreatedList(ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move the selected document to the thrash.
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsDelete(documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsDelete(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of duplicated documents.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsDuplicatedList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsDuplicatedList(ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of the selected document\'s duplicates.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsDuplicatesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsDuplicatesList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new document to the list of favorite documents for the current user.
     * @param {FavoriteDocument} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFavoritesCreate(data: FavoriteDocument, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFavoritesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the selected favorite document.
     * @param {string} favoriteDocumentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFavoritesDelete(favoriteDocumentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFavoritesDelete(favoriteDocumentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of the favorite documents for the current user.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFavoritesList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFavoritesList(ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the details of the selected favorite document.
     * @param {string} favoriteDocumentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFavoritesRead(favoriteDocumentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFavoritesRead(favoriteDocumentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document file.
     * @param {string} documentId 
     * @param {DocumentFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesCreate(documentId: string, data: DocumentFile, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesCreate(documentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the selected document file.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesDelete(documentId: string, documentFileId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesDelete(documentId, documentFileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a document file.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesDownloadRead(documentId: string, documentFileId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesDownloadRead(documentId, documentFileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the list of file metadata entries for the selected driver.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} driverId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesFileMetadataDriversEntriesList(documentId: string, documentFileId: string, driverId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesFileMetadataDriversEntriesList(documentId, documentFileId, driverId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the detail of selected document file metadata entry.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} driverId 
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesFileMetadataDriversEntriesRead(documentId: string, documentFileId: string, driverId: string, entryId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesFileMetadataDriversEntriesRead(documentId, documentFileId, driverId, entryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of selected document\'s file metadata drivers.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesFileMetadataDriversList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesFileMetadataDriversList(documentId, documentFileId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of the document file metadata driver.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} driverId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesFileMetadataDriversRead(documentId: string, documentFileId: string, driverId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesFileMetadataDriversRead(documentId, documentFileId, driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a document file for file metadata processing.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesFileMetadataSubmitCreate(documentId: string, documentFileId: string, data: object, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesFileMetadataSubmitCreate(documentId, documentFileId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of the selected document\'s files.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the content of the selected document page.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} documentFilePageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesPagesContentRead(documentId: string, documentFileId: string, documentFilePageId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesPagesContentRead(documentId, documentFileId, documentFilePageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an image representation of the selected document.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} documentFilePageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesPagesImageRead(documentId: string, documentFileId: string, documentFilePageId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesPagesImageRead(documentId, documentFileId, documentFilePageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesPagesList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesPagesList(documentId, documentFileId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the selected document page details.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} documentFilePageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesPagesRead(documentId: string, documentFileId: string, documentFilePageId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesPagesRead(documentId, documentFileId, documentFilePageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {DocumentFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesPartialUpdate(documentId: string, documentFileId: string, data: DocumentFile, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesPartialUpdate(documentId, documentFileId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the selected document file details.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesRead(documentId: string, documentFileId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesRead(documentId, documentFileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an detached signature of the selected document.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} detachedSignatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesSignaturesDetachedDelete(documentId: string, documentFileId: string, detachedSignatureId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesSignaturesDetachedDelete(documentId, documentFileId, detachedSignatureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the detached signatures of a document file.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesSignaturesDetachedList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesSignaturesDetachedList(documentId, documentFileId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of the selected detached signature.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} detachedSignatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesSignaturesDetachedRead(documentId: string, documentFileId: string, detachedSignatureId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesSignaturesDetachedRead(documentId, documentFileId, detachedSignatureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sign a document file with a detached signature.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {SignDetached} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesSignaturesDetachedSignCreate(documentId: string, documentFileId: string, data: SignDetached, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesSignaturesDetachedSignCreate(documentId, documentFileId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a detached signature file for a document file.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {DetachedSignatureUpload} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesSignaturesDetachedUploadCreate(documentId: string, documentFileId: string, data: DetachedSignatureUpload, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesSignaturesDetachedUploadCreate(documentId, documentFileId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the embedded signatures of a document file.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesSignaturesEmbeddedList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesSignaturesEmbeddedList(documentId, documentFileId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the details of the selected embedded signature.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} embeddedSignatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesSignaturesEmbeddedRead(documentId: string, documentFileId: string, embeddedSignatureId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesSignaturesEmbeddedRead(documentId, documentFileId, embeddedSignatureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sign a document file with an embedded signature.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {SignEmbedded} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesSignaturesEmbeddedSignCreate(documentId: string, documentFileId: string, data: SignEmbedded, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesSignaturesEmbeddedSignCreate(documentId, documentFileId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of selected document\'s source metadata values.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesSourceMetadataList(documentId: string, documentFileId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesSourceMetadataList(documentId, documentFileId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the details of the selected document source metadata.
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {string} documentFileSourceMetadataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesSourceMetadataRead(documentId: string, documentFileId: string, documentFileSourceMetadataId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesSourceMetadataRead(documentId, documentFileId, documentFileSourceMetadataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentId 
     * @param {string} documentFileId 
     * @param {DocumentFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsFilesUpdate(documentId: string, documentFileId: string, data: DocumentFile, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsFilesUpdate(documentId, documentFileId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the indexes instance nodes where this document is found.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsIndexesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsIndexesList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the documents.
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsList(ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsList(ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an existing metadata type and value to the selected document.
     * @param {string} documentId 
     * @param {DocumentMetadata} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsMetadataCreate(documentId: string, data: DocumentMetadata, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsMetadataCreate(documentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove this metadata entry from the selected document.
     * @param {string} documentId 
     * @param {string} metadataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsMetadataDelete(documentId: string, metadataId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsMetadataDelete(documentId, metadataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of selected document\'s metadata types and values.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsMetadataList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsMetadataList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the selected document metadata type and value.
     * @param {string} documentId 
     * @param {string} metadataId 
     * @param {DocumentMetadata} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsMetadataPartialUpdate(documentId: string, metadataId: string, data: DocumentMetadata, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsMetadataPartialUpdate(documentId, metadataId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the details of the selected document metadata type and value.
     * @param {string} documentId 
     * @param {string} metadataId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsMetadataRead(documentId: string, metadataId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsMetadataRead(documentId, metadataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the selected document metadata type and value.
     * @param {string} documentId 
     * @param {string} metadataId 
     * @param {DocumentMetadata} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsMetadataUpdate(documentId: string, metadataId: string, data: DocumentMetadata, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsMetadataUpdate(documentId, metadataId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a document for OCR.
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsOcrSubmitCreate(documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsOcrSubmitCreate(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the properties of the selected document.
     * @param {string} documentId 
     * @param {Document} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsPartialUpdate(documentId: string, data: Document, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsPartialUpdate(documentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the details of the selected document.
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsRead(documentId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsRead(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the smart link documents that apply to the document.
     * @param {string} documentId 
     * @param {string} resolvedSmartLinkId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsResolvedSmartLinksDocumentsList(documentId: string, resolvedSmartLinkId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsResolvedSmartLinksDocumentsList(documentId, resolvedSmartLinkId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the smart links that apply to the document.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsResolvedSmartLinksList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsResolvedSmartLinksList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the details of the selected resolved smart link.
     * @param {string} documentId 
     * @param {string} resolvedSmartLinkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsResolvedSmartLinksRead(documentId: string, resolvedSmartLinkId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsResolvedSmartLinksRead(documentId, resolvedSmartLinkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of resolved web links for the specified document.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsResolvedWebLinksList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsResolvedWebLinksList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a redirection to the target URL of the selected resolved smart link.
     * @param {string} documentId 
     * @param {string} resolvedWebLinkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsResolvedWebLinksNavigateRead(documentId: string, resolvedWebLinkId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsResolvedWebLinksNavigateRead(documentId, resolvedWebLinkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the details of the selected resolved smart link.
     * @param {string} documentId 
     * @param {string} resolvedWebLinkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsResolvedWebLinksRead(documentId: string, resolvedWebLinkId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsResolvedWebLinksRead(documentId, resolvedWebLinkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new signature_capture.
     * @param {string} documentId 
     * @param {SignatureCapture} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsSignatureCapturesCreate(documentId: string, data: SignatureCapture, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsSignatureCapturesCreate(documentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the selected signature_capture.
     * @param {string} documentId 
     * @param {string} signatureCaptureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsSignatureCapturesDelete(documentId: string, signatureCaptureId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsSignatureCapturesDelete(documentId, signatureCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an image representation of the selected signature capture.
     * @param {string} documentId 
     * @param {string} signatureCaptureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsSignatureCapturesImageRead(documentId: string, signatureCaptureId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsSignatureCapturesImageRead(documentId, signatureCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the signature_captures.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsSignatureCapturesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsSignatureCapturesList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the selected signature_capture.
     * @param {string} documentId 
     * @param {string} signatureCaptureId 
     * @param {SignatureCapture} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsSignatureCapturesPartialUpdate(documentId: string, signatureCaptureId: string, data: SignatureCapture, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsSignatureCapturesPartialUpdate(documentId, signatureCaptureId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the details of the selected signature_capture.
     * @param {string} documentId 
     * @param {string} signatureCaptureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsSignatureCapturesRead(documentId: string, signatureCaptureId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsSignatureCapturesRead(documentId, signatureCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the selected signature_capture.
     * @param {string} documentId 
     * @param {string} signatureCaptureId 
     * @param {SignatureCapture} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsSignatureCapturesUpdate(documentId: string, signatureCaptureId: string, data: SignatureCapture, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsSignatureCapturesUpdate(documentId, signatureCaptureId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attach a tag to a document.
     * @param {string} documentId 
     * @param {DocumentTagAttach} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsTagsAttachCreate(documentId: string, data: DocumentTagAttach, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsTagsAttachCreate(documentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the tags attached to a document.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsTagsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsTagsList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag from a document.
     * @param {string} documentId 
     * @param {DocumentTagRemove} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsTagsRemoveCreate(documentId: string, data: DocumentTagRemove, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsTagsRemoveCreate(documentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the type of the selected document.
     * @param {string} documentId 
     * @param {DocumentChangeType} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsTypeChangeCreate(documentId: string, data: DocumentChangeType, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsTypeChangeCreate(documentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the properties of the selected document.
     * @param {string} documentId 
     * @param {Document} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsUpdate(documentId: string, data: Document, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsUpdate(documentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document and a new document file.
     * @param {DocumentUpload} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsUploadCreate(data: DocumentUpload, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsUploadCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document version.
     * @param {string} documentId 
     * @param {DocumentVersion} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsCreate(documentId: string, data: DocumentVersion, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsCreate(documentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the selected document version.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsDelete(documentId: string, documentVersionId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsDelete(documentId, documentVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exports the specified document version.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsExportCreate(documentId: string, documentVersionId: string, data: object, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsExportCreate(documentId, documentVersionId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of the selected document\'s versions.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute a modification backend on the selected document version.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {DocumentVersionModificationExecute} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsModifyCreate(documentId: string, documentVersionId: string, data: DocumentVersionModificationExecute, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsModifyCreate(documentId, documentVersionId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a document version for OCR.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsOcrSubmitCreate(documentId: string, documentVersionId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsOcrSubmitCreate(documentId, documentVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document version page.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {DocumentVersionPage} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsPagesCreate(documentId: string, documentVersionId: string, data: DocumentVersionPage, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsPagesCreate(documentId, documentVersionId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the selected document version page.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {string} documentVersionPageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsPagesDelete(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsPagesDelete(documentId, documentVersionId, documentVersionPageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an image representation of the selected document version page.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {string} documentVersionPageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsPagesImageRead(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsPagesImageRead(documentId, documentVersionId, documentVersionPageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an list of the pages for the selected document version.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsPagesList(documentId: string, documentVersionId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsPagesList(documentId, documentVersionId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the OCR content of the selected document page.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {string} documentVersionPageId 
     * @param {DocumentVersionPageOCRContent} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsPagesOcrPartialUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPageOCRContent, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsPagesOcrPartialUpdate(documentId, documentVersionId, documentVersionPageId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the OCR content of the selected document page.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {string} documentVersionPageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsPagesOcrRead(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsPagesOcrRead(documentId, documentVersionId, documentVersionPageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the OCR content of the selected document page.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {string} documentVersionPageId 
     * @param {DocumentVersionPageOCRContent} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsPagesOcrUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPageOCRContent, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsPagesOcrUpdate(documentId, documentVersionId, documentVersionPageId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the properties of the selected document version page.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {string} documentVersionPageId 
     * @param {DocumentVersionPage} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsPagesPartialUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPage, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsPagesPartialUpdate(documentId, documentVersionId, documentVersionPageId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the selected document version page details.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {string} documentVersionPageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsPagesRead(documentId: string, documentVersionId: string, documentVersionPageId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsPagesRead(documentId, documentVersionId, documentVersionPageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the properties of the selected document version page.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {string} documentVersionPageId 
     * @param {DocumentVersionPage} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsPagesUpdate(documentId: string, documentVersionId: string, documentVersionPageId: string, data: DocumentVersionPage, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsPagesUpdate(documentId, documentVersionId, documentVersionPageId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the properties of the selected document version.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {DocumentVersion} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsPartialUpdate(documentId: string, documentVersionId: string, data: DocumentVersion, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsPartialUpdate(documentId, documentVersionId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the selected document version details.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsRead(documentId: string, documentVersionId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsRead(documentId, documentVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit the properties of the selected document version.
     * @param {string} documentId 
     * @param {string} documentVersionId 
     * @param {DocumentVersion} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsVersionsUpdate(documentId: string, documentVersionId: string, data: DocumentVersion, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsVersionsUpdate(documentId, documentVersionId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Launch a new workflow instance for the specified document.
     * @param {string} documentId 
     * @param {WorkflowInstanceLaunch} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsWorkflowInstancesLaunchCreate(documentId: string, data: WorkflowInstanceLaunch, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsWorkflowInstancesLaunchCreate(documentId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the document workflow instances.
     * @param {string} documentId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsWorkflowInstancesList(documentId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsWorkflowInstancesList(documentId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transition a document workflow by creating a new document workflow instance log entry.
     * @param {string} documentId 
     * @param {string} workflowInstanceId 
     * @param {WorkflowInstanceLogEntry} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsWorkflowInstancesLogEntriesCreate(documentId: string, workflowInstanceId: string, data: WorkflowInstanceLogEntry, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsWorkflowInstancesLogEntriesCreate(documentId, workflowInstanceId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the document workflow instances log entries.
     * @param {string} documentId 
     * @param {string} workflowInstanceId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsWorkflowInstancesLogEntriesList(documentId: string, workflowInstanceId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsWorkflowInstancesLogEntriesList(documentId, workflowInstanceId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the details of the selected document instances log entry.
     * @param {string} documentId 
     * @param {string} workflowInstanceId 
     * @param {string} workflowInstanceLogEntryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsWorkflowInstancesLogEntriesRead(documentId: string, workflowInstanceId: string, workflowInstanceLogEntryId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsWorkflowInstancesLogEntriesRead(documentId, workflowInstanceId, workflowInstanceLogEntryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all the possible transition choices for the workflow instance.
     * @param {string} documentId 
     * @param {string} workflowInstanceId 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsWorkflowInstancesLogEntriesTransitionsList(documentId: string, workflowInstanceId: string, ordering?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsWorkflowInstancesLogEntriesTransitionsList(documentId, workflowInstanceId, ordering, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the details of the selected document workflow instances.
     * @param {string} documentId 
     * @param {string} workflowInstanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsWorkflowInstancesRead(documentId: string, workflowInstanceId: string, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsWorkflowInstancesRead(documentId, workflowInstanceId, options).then((request) => request(this.axios, this.basePath));
    }
}

